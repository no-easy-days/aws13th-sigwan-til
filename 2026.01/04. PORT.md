> [!note] Port   
> **포트(Port)는 “한 컴퓨터(IP) 안에서 어떤 프로세스(프로그램)로 데이터를 보낼지”를 정하는 번호**다.  
> 네트워크에서 최종 목적지는 보통 **(프로토콜, IP, 포트)** 조합으로 결정된다.  
> 실무에서 “접속이 안 된다”의 원인은 대부분 **(1) 서버가 해당 포트에서 LISTEN 중인지 (2) 방화벽/보안그룹이 포트를 막는지 (3) NAT/포트포워딩이 올바른지 (4) 프로세스가 로컬에만 바인딩(127.0.0.1) 된 건 아닌지**로 분해해서 본다.

# Port (TCP/UDP Port)

## 1) 정의 및 간결한 설명

**포트(Port)**는 한 컴퓨터에 들어온 네트워크 데이터를 **어떤 프로그램(프로세스/서비스)**에게 전달할지 구분하기 위한 **16비트 번호(0~65535)**다.

- **IP 주소**: “어느 컴퓨터(또는 네트워크 인터페이스)로 갈 것인가”
    
- **포트 번호**: “그 컴퓨터 안에서 어느 프로그램으로 갈 것인가”
    

즉, 네트워크 통신에서 실제 식별자는 보통 아래처럼 생각하면 된다.

- **TCP 연결의 식별(기본 개념)**:  
    `(출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트, 프로토콜(TCP/UDP))`  
    → 흔히 **5-tuple**이라고 부른다.
    

> [!note] 용어 정리
> 
> - **TCP/UDP**: 포트 개념은 주로 TCP/UDP 같은 전송 계층(L4)에서 등장
>     
> - **소켓(Socket)**: OS가 “(프로토콜, IP, 포트)”로 통신 창구를 관리하는 단위
>     
> - **LISTEN**: 서버 프로세스가 “이 포트로 들어오는 연결을 받겠다”고 대기 중인 상태
>     

---
## 2) 왜 그렇게 설계됐는지(철학/트레이드오프)

### 2.1 포트(Port)가 필요한 이유

IP 주소는 **패킷을 “어느 컴퓨터(호스트)”까지 보낼지**를 결정하는 식별자이다. 그러나 하나의 호스트에는 동시에 여러 네트워크 프로그램이 동작한다(예: 웹 서버, DB, SSH, 캐시 서버, 모니터링 에이전트 등).  
따라서 “호스트에 도착한 다음, 그 패킷을 **어느 프로그램(프로세스)** 에 전달할 것인가”를 구분할 추가 식별자가 필요하다. 이 역할을 수행하는 것이 **포트 번호(Port Number)** 이다.

정리하면 다음과 같다.

- **IP 주소**: 목적지 “호스트(컴퓨터)”를 식별
    
- **포트 번호**: 목적지 호스트 내부의 “서비스/프로세스(프로그램)”를 식별
    

포트가 없으면 OS(커널)는 동일한 목적지 IP로 들어온 패킷을 **웹 서버로 줄지, DB로 줄지, SSH로 줄지**를 구분할 수 없으며, 결과적으로 하나의 호스트에서 다중 서비스 운영이 구조적으로 불가능해진다.

---

### 2.2 설계 철학: “전 세계 라우팅”과 “호스트 내부 디스패치”의 분리

인터넷은 크게 두 단계를 분리해서 처리한다.

1. **네트워크 계층(IP)**: 전 세계적으로 “어느 호스트로 갈지”를 라우팅
    
2. **전송 계층(TCP/UDP + Port)**: 호스트에 도착한 뒤 “어느 프로세스가 받을지”를 디스패치
    

이 분리 덕분에 라우터/ISP/백본 장비는 **호스트 내부 서비스 구성**을 알 필요가 없고, 호스트(OS)는 네트워크가 어떻게 라우팅했는지와 무관하게 **내부 프로세스 단위로 정확히 분배**할 수 있다. 즉, 확장성과 역할 분리가 동시에 달성된다.

---

### 2.3 트레이드오프(현실에서 생기는 문제)

#### (1) 포트 충돌(Port conflict)

하나의 IP에서 동일 프로토콜(TCP 기준)로 **같은 포트는 일반적으로 하나의 프로세스만 LISTEN** 할 수 있다.

- 예: `3306/TCP`에 이미 MySQL이 LISTEN 중이면, 다른 DB 서버는 같은 포트를 사용할 수 없다.
    
- 결과: 개발/운영 환경에서 “포트가 이미 사용 중” 문제가 빈번하게 발생한다.
    

#### (2) 보안 표면 확대(Attack surface 증가)

열린 포트는 외부에서 접근 가능한 **진입 지점(entry point)** 이 된다.

- 불필요한 서비스가 포트를 열고 있으면 스캔 대상이 된다.
    
- 운영 원칙: “필요한 포트만 열고, 나머지는 차단”  
    (방화벽, 보안그룹, 접근제어 목록을 통해 관리)
    

#### (3) NAT/PAT 환경에서 포트의 중요성 증가

사설망(예: `192.168.x.x`)에서 외부로 나갈 때 NAT가 주소를 변환하며, 실무에서는 대개 **포트까지 함께 변환(PAT)** 한다.

- 내부 PC의 `192.168.0.10:53422`가 외부에서는 `공인IP:61001`처럼 보일 수 있다.
    
- 결과: “내 PC에서 보이는 출발지 포트”와 “인터넷에서 관측되는 포트”가 달라질 수 있고, 추적/디버깅 난이도가 증가한다.
    

---

## 3) 내부에서 실제로 일어나는 일(자료구조/파일/메모리/네트워크) — 단계별

### 3.1 서버에서 “포트를 연다”는 의미: bind → listen → accept

TCP 서버 프로그램은 일반적으로 다음 순서로 동작한다.

1. **socket()**
    
    - 커널에 “통신용 엔드포인트(소켓)” 생성을 요청한다.
        
    - 커널 내부에는 소켓 객체(커널 자료구조)가 생성되고 파일 디스크립터(FD)가 프로세스에 반환된다.
        
2. **bind(IP, Port)**
    
    - “이 IP의 이 포트로 들어오는 트래픽을 내가 받겠다”를 커널에 등록한다.
        
    - 예:
        
        - `0.0.0.0:8080` : 모든 네트워크 인터페이스에서 8080 수신
            
        - `127.0.0.1:8080` : 로컬 인터페이스에서만 수신(외부 접속 불가)
            
3. **listen(backlog)**
    
    - 커널에 “연결 요청을 받을 준비가 되었고, 연결 요청 큐(backlog)를 운영하겠다”를 선언한다.
        
    - 이 시점부터 포트는 외부에서 관측 시 “LISTEN” 상태가 된다.
        
4. **accept()**
    
    - 클라이언트가 연결을 시도하면 커널이 TCP 핸드셰이크를 처리하고,
        
    - 연결이 성립되면 서버 프로세스는 `accept()`를 통해 **새로운 연결 소켓(FD)** 을 하나 더 받는다.
        
    - 즉, “LISTEN 소켓”과 “연결 소켓(클라이언트별 소켓)”은 구분된다.
        

> 핵심 정리:  
> **포트를 연다 = 커널의 소켓 테이블에 (프로토콜, IP, 포트) 조합을 등록하고 LISTEN 상태로 대기한다**는 의미이다.

---

### 3.2 클라이언트 출발지 포트가 매번 달라지는 이유: Ephemeral Port

클라이언트가 서버 `example.com:443`에 접속할 때도 출발지 포트가 필요하다. 이 출발지 포트는 대개 OS가 **동적/임시 포트(ephemeral port)** 범위에서 자동으로 할당한다.

- 예:
    
    - 클라이언트: `192.168.0.10:53422`
        
    - 서버: `93.184.216.34:443`
        

같은 서버에 여러 번 접속해도 출발지 포트가 바뀌는 것은 정상이며, 이는 동시 연결을 안전하게 분리하기 위한 운영 방식이다.

---

### 3.3 OS가 “어느 프로그램에게 줄지” 결정하는 기준: 소켓 테이블과 4-튜플

커널은 패킷을 받으면 다음 정보를 바탕으로 전달 대상을 결정한다.

- 프로토콜(TCP/UDP)
    
- 목적지 IP
    
- 목적지 Port
    
- (연결이 성립된 경우) 출발지 IP, 출발지 Port
    

TCP에서는 흔히 **4-튜플(출발지 IP/Port + 목적지 IP/Port)** 로 “연결”이 식별된다.  
커널은 소켓 테이블에서:

- 우선 “LISTEN 소켓”을 찾거나
    
- 이미 연결된 “ESTABLISHED 소켓”을 찾아
    

해당 프로세스의 소켓 버퍼로 데이터를 전달한다.

---

### 3.4 포트는 운영/보안에서 “차단 규칙의 단위”가 된다

서버가 LISTEN 중이어도, 네트워크 경로 중간에서 포트가 차단되면 외부 접속은 실패한다.

대표적인 차단 지점:

- 로컬 방화벽(macOS pf 등)
    
- 공유기 NAT/포트포워딩 규칙
    
- 회사 방화벽/IDS/IPS
    
- 클라우드 보안그룹(AWS Security Group 등)
    

즉, “프로세스가 포트를 열었다”는 사실과 “외부에서 접속 가능하다”는 사실은 동일하지 않다.

---

## 4) 내가 직접 확인할 수 있게 재현 절차(macOS 중심)

### 4.1 현재 LISTEN 중인 포트와 프로세스 확인

**명령어**

```bash
sudo lsof -nP -iTCP -sTCP:LISTEN
```

**예상 출력(형식 예시)**

```
COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
node    12345 you    23u  IPv4 0x...              0t0  TCP *:3000 (LISTEN)
mysqld  23456 _mysql 30u  IPv4 0x...              0t0  TCP 127.0.0.1:3306 (LISTEN)
```

**체크 포인트**

- `*:3000` : 모든 인터페이스에서 수신(외부 접근 가능성이 생김)
    
- `127.0.0.1:3306` : 로컬 전용(외부 접속 불가)
    
- `COMMAND/PID` : 어떤 프로세스가 포트를 점유하는지 즉시 확인 가능
    

---

### 4.2 특정 포트가 “열려 있는지” 빠르게 점검

**명령어**

```bash
nc -vz 127.0.0.1 8080
```

**예상 출력**

- 성공: `succeeded`
    
- 실패: `failed` 또는 `Connection refused`
    
- 타임아웃: `timed out`
    

**체크 포인트**

- `Connection refused` : 해당 포트에 LISTEN 프로세스가 없음인 경우가 많음
    
- `timed out` : 네트워크 경로/방화벽 차단 가능성을 강하게 시사
    

---

### 4.3 외부 서버 포트(예: 443, 22)가 열려 있는지 확인

**명령어**

```bash
nc -vz example.com 443
nc -vz example.com 22
```

**예상 출력**

- 열려 있으면 `succeeded`
    
- 차단이면 timeout/failed
    

**체크 포인트**

- DNS 문제를 배제하려면 도메인 대신 **IP로도 테스트**하면 원인 분리가 더 쉬움
    

---

### 4.4 연결 상태(ESTABLISHED)와 TCP 상태 확인

**명령어**

```bash
netstat -anv | head
# 또는
lsof -nP -iTCP -sTCP:ESTABLISHED | head
```

**예상 출력(상태 예시)**

- `LISTEN`
    
- `ESTABLISHED`
    
- `SYN_SENT`
    
- `TIME_WAIT`
    

**체크 포인트**

- `LISTEN` : 서버가 대기 중
    
- `ESTABLISHED` : 연결 성립
    
- `SYN_SENT`가 오래 지속 : 상대가 응답하지 않음(포트 차단/방화벽 가능성)
    

---

## 5) 흔한 오해 3개 + 반례

### 오해 1) “포트는 물리적인 구멍이다”

**반례**: 포트는 OS 커널이 관리하는 번호 체계이며, 프로세스가 `bind/listen` 할 때만 의미가 생긴다. 프로세스가 종료되면 포트는 즉시 해제된다.

### 오해 2) “포트가 열려 있으면 누구나 접속 가능하다”

**반례**: `127.0.0.1:3306`처럼 로컬 바인딩이면 외부 접근이 불가능하다. 또한 보안그룹/방화벽이 차단하면 LISTEN 중이어도 외부에서는 timeout이 발생한다.

### 오해 3) “HTTP는 80, HTTPS는 443만 사용한다”

**반례**: 개발 환경에서는 `localhost:3000`, `localhost:8080`처럼 비표준 포트를 흔히 사용한다. 80/443은 “기본 포트(default)”일 뿐이며, 실제 서비스 포트는 정책/환경에 따라 달라질 수 있다.

---

### 부록: 실무에서 특히 자주 보는 포인트(요약)

- `0.0.0.0` 바인딩은 외부 노출 가능성이 커지므로 보안 정책과 함께 사용해야 한다.
    
- NAT 환경에서는 “내 PC에서 본 포트”와 “외부에서 보이는 포트”가 달라질 수 있다(PAT).
    
- UDP도 포트를 사용하지만, TCP처럼 연결 상태(ESTABLISHED)가 아니라 데이터그램 중심으로 관측 방식이 다르다.