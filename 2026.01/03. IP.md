> [!note] IP 
> **IP 주소는 “패킷이 어디로 가야 하는지(목적지) + 누가 보냈는지(출발지)”를 표시하는 네트워크 계층(L3) 주소**다.  
> IPv4는 **32비트**이고, 이 32비트는 라우팅을 위해 보통 **네트워크 부분(어느 네트워크로 갈지)** 과 **호스트 부분(그 안에서 어느 기기인지)** 으로 나뉘어 해석된다.  
> 실무에서 IP 문제를 볼 때 핵심은 **(1) 내 IP/서브넷(/24 같은 경계) (2) 라우팅 테이블이 고른 ‘다음 홉’ (3) ARP/ND로 MAC을 찾았는지 (4) 중간 라우터에서 TTL/MTU/NAT로 막히는지**를 단계별로 분해하는 것이다.

---

# 1) IP (Internet Protocol) Address

## 1) 정의 및 간결한 설명

IP 주소(IP Address)는 인터넷에서 통신하는 상대를 특정하기 위한 **식별자**다. 다만 “식별자”라고 해서 단순히 기기에 붙은 번호만을 뜻하는 게 아니라, **네트워크에서 패킷이 이동할 수 있도록(라우팅이 가능하도록) 설계된 주소 체계**라는 점이 핵심이다.

일반적으로 우리가 “IP 주소”라고 말할 때는 **IPv4**를 먼저 떠올린다. IPv4 주소는 **총 32비트(0과 1이 32개)**로 구성된다. 하지만 0/1을 32자리로 늘어놓는 방식은 사람이 읽기 불편하기 때문에, 보통 32비트를 **8비트씩 4묶음**으로 나눈 뒤, 각 묶음을 **10진수(0~255)** 로 바꿔 점(`.`)으로 구분해 표기한다.

예를 들어 아래처럼 보인다.

- `201.0.159.32`
    
- `93.184.216.34` (예: example.com이 가질 수 있는 IPv4)
    
여기서 중요한 사실 하나가 더 있다. IP 주소는 겉보기엔 `x.x.x.x` 형태의 “숫자 4개”지만, 네트워크가 이 주소를 다룰 때는 보통 **두 종류의 정보**로 나눠서 이해한다.

- **네트워크 부분**: “어느 네트워크(어느 대역)로 가야 하는가”
    
- **호스트 부분**: “그 네트워크 안에서 어느 기기(호스트)인가”
    
> [!note] 용어 정리 — IP를 이해할 때 꼭 필요한 단어
> 
> - **IPv4**: 32비트 주소 체계. 사람이 보기 쉽게 `x.x.x.x`로 표기
>     
> - **패킷(Packet)**: 네트워크에서 실제로 이동하는 데이터 단위(출발지/목적지 주소 포함)
>     
> - **라우팅(Routing)**: 목적지 IP를 보고 “다음에 어디로 보내야 하는지”를 결정하는 과정
>     
> - **서브넷 마스크 / CIDR(/24)**: 네트워크/호스트 경계를 정하는 규칙
>     

---

## 2) 왜 그렇게 설계됐는지(철학/트레이드오프)

IP 주소가 “네트워크 부분 + 호스트 부분”으로 나뉘어 해석되는 이유는 단순하다. 인터넷은 전 세계 수많은 기기가 연결된 구조라서, 매번 “기기 하나하나를 목적지로 삼아” 길찾기를 하면 라우터가 감당할 수 없을 정도로 비효율적이 된다. 그래서 IP는 **네트워크 단위로 먼저 크게 묶어서** 길을 찾고, 목적지 네트워크에 도착한 다음 **그 안에서 호스트를 찾는** 방식으로 설계됐다.

이 설계는 성능과 확장성에서 큰 이점을 주지만, 그에 따른 트레이드오프도 함께 생긴다.

1. **경계(네트워크/호스트)가 고정이 아니라 설정에 따라 바뀐다**  
    예전에 교재에서 “왼쪽 24비트가 네트워크 주소, 오른쪽이 호스트 주소”라고 배우는 경우가 많은데, 이건 **/24라는 매우 흔한 사례**를 설명한 것이다. 실제 경계는 네트워크 설계에 따라 /16, /20, /27 등 다양하게 쓰인다.  
    장점은 네트워크를 유연하게 쪼갤 수 있다는 것이고, 단점은 초심자 입장에서는 “왜 어떤 때는 24비트고 어떤 때는 아니지?” 같은 혼란이 생긴다는 것이다.
    
2. **IPv4는 32비트라서 주소가 부족해졌다 → NAT라는 우회가 널리 쓰인다**  
    IPv4 전체 주소 공간은 2³²개로 시작했지만, 실제 인터넷이 커지면서 부족 문제가 발생했다. 그래서 많은 환경에서 사설 IP(예: `192.168.x.x`, `10.x.x.x`)를 내부에서 쓰고, 외부로 나갈 때 공유기/방화벽에서 공인 IP로 변환하는 **NAT**가 표준처럼 자리 잡았다.  
    장점은 주소 부족을 완화한다는 것이고, 단점은 “원래 IP가 의도하던 끝단-끝단 직접 연결(end-to-end)”이 깨져서 일부 통신/디버깅이 복잡해진다는 것이다.
    
3. **IP 자체는 ‘최선형(best-effort)’ 전달이라 신뢰성은 TCP 같은 상위 계층이 맡는다**  
    IP는 “목적지까지 보내보자”에 집중한다. 중간에 패킷이 유실되거나 순서가 섞여도 IP는 그 자체로 복구를 책임지지 않는다. 그래서 웹(HTTPS)처럼 안정성이 필요한 통신은 보통 TCP(또는 QUIC)를 위에 얹는다.  
    장점은 네트워크 계층을 단순하고 빠르게 유지할 수 있다는 것이고, 단점은 “신뢰성은 상위 계층이 별도로 처리해야 한다”는 구조적 분리가 생긴다.
    

> [!note] 용어 정리 — CIDR과 NAT
> 
> - **CIDR(/24)**: “앞의 24비트가 네트워크 부분”이라는 뜻. IPv4 주소를 네트워크 단위로 묶는 표준 표기
>     
> - **NAT**: 내부 사설 IP들을 하나/몇 개의 공인 IP로 변환해 외부 통신을 가능하게 하는 방식(대부분 공유기/방화벽이 수행)
>     

---

## 3) 내부에서 실제로 일어나는 일(자료구조/파일/메모리/네트워크) — 단계별

이 절은 “내 컴퓨터가 어떤 서버 IP로 패킷을 보내는 순간”을 가정해, OS 내부에서 실제로 어떤 일이 벌어지는지 순서대로 정리한다. 예시는 이해를 위해 `93.184.216.34`(example.com이 가질 수 있는 IP) 같은 외부 IP로 접속한다고 가정한다.

### 3.1 애플리케이션이 “목적지 IP로 보내라”는 요청을 만든다 (소켓 → 커널)

브라우저/앱은 연결을 시도할 때 OS에 소켓(socket) 호출로 요청한다. 이 순간부터는 사용자 공간(user space)이 아니라 커널(kernel)이 패킷 전송을 담당한다.  
커널 입장에서는 “목적지 IP가 이거고, 전송 프로토콜(TCP/UDP)이 이거고, 목적지 포트가 이거다”라는 정보가 주어진 셈이다.

> [!note] 용어 정리 — 소켓(Socket)
> 
> - 애플리케이션이 네트워크 통신을 하기 위해 OS에 요청하는 인터페이스
>     
> - “보낼 주소(IP)와 포트, 프로토콜(TCP/UDP)을 지정하면 OS가 패킷 전송을 처리한다” 정도로 이해하면 충분하다
>     

### 3.2 커널이 “내 IP / 내 서브넷 / 라우팅 테이블”을 보고 경로를 결정한다 (라우팅 테이블)

커널은 먼저 “이 목적지 IP가 내 로컬 네트워크에 있는지, 아니면 밖(인터넷)에 있는지”를 판단한다.  
이때 쓰는 핵심 정보가 다음 2개다.

- **내 인터페이스의 IP와 서브넷 경계(CIDR 또는 netmask)**
    
- **라우팅 테이블(routing table)**: “어떤 목적지 대역은 어느 게이트웨이/인터페이스로 보낼지” 규칙 목록
    

예를 들어 내 컴퓨터가 `192.168.0.10/24`라면, `192.168.0.x` 대역은 보통 “로컬 네트워크(같은 Wi-Fi)”로 판단하고, 그 외는 “기본 게이트웨이(공유기)로 보낸다”가 된다.

> [!note] 용어 정리 — 라우팅 테이블 / 기본 게이트웨이
> 
> - **라우팅 테이블**: 목적지 IP(정확히는 목적지 대역)에 따라 다음 홉을 고르는 규칙표
>     
> - **기본 게이트웨이(default gateway)**: “로컬에 없으면 일단 여기로 보낸다”라고 지정된 라우터(대부분 공유기)
>     

### 3.3 다음 홉의 “MAC 주소”가 필요하다 (IPv4라면 ARP)

IP는 네트워크 계층(L3) 주소다. 그런데 실제로 내 컴퓨터가 같은 LAN(Wi-Fi/Ethernet)에서 프레임을 보낼 때는 링크 계층(L2) 주소인 **MAC 주소**가 필요하다.  
즉, 커널이 라우팅 테이블로 “다음 홉은 공유기(192.168.0.1)다”라고 결정했다면, 이제는 “그 공유기의 MAC 주소가 뭐지?”를 알아야 실제 프레임을 만들 수 있다.

- IPv4에서는 보통 **ARP(Address Resolution Protocol)**로 “IP → MAC”을 물어본다.
    
- 이 결과는 **ARP 캐시(메모리)**에 일정 시간 저장된다.
    

> [!note] 용어 정리 — ARP와 ARP 캐시
> 
> - **ARP**: 같은 LAN에서 “이 IP를 가진 장비의 MAC 주소가 뭐야?”를 알아내는 프로토콜
>     
> - **ARP 캐시**: ARP로 알아낸 결과를 메모리에 저장해 반복 질의를 줄이는 캐시
>     

### 3.4 IP 패킷을 만든다 (IP 헤더 + 페이로드)

다음 홉 MAC까지 준비되면, 커널은 실제로 **IP 패킷**을 만든다. 이때 IP 패킷에는 “데이터”만 있는 게 아니라, 라우팅을 위해 필요한 **IP 헤더**가 붙는다. 대표적으로 이런 값들이 들어간다.

- **출발지 IP / 목적지 IP**
    
- **TTL(Time To Live)**: 라우터를 몇 번까지 통과할 수 있는지(무한 루프 방지)
    
- **Protocol 필드**: 위에 얹힌 것이 TCP인지(6) UDP인지(17)
    
- (상황에 따라) **조각화(fragmentation) 관련 필드**
    

여기서 TTL은 DNS의 TTL과 완전히 다른 개념이다. DNS TTL은 “캐시 시간”이고, IP TTL은 “라우터를 몇 번까지 통과할 수 있는지”다.

> [!note] 용어 정리 — IP TTL (DNS TTL과 다름)
> 
> - **IP TTL**: 라우터를 한 번 지날 때마다 1씩 감소. 0이 되면 폐기되고 보통 “Time Exceeded”가 돌아온다.
>     
> - 목적: 라우팅 루프(길을 못 찾고 빙빙 도는 상황)에서 패킷이 영원히 떠도는 것을 방지
>     

### 3.5 링크 계층 프레임으로 감싸서 NIC로 전송한다 (Ethernet/Wi-Fi)

IP 패킷이 만들어지면, 이 패킷은 그대로 공중에 날아가는 게 아니라, 실제 물리 네트워크로 보내기 위해 **링크 계층 프레임**에 담긴다.

- 프레임에는 **출발지 MAC / 목적지 MAC**이 들어간다.
    
- 목적지 MAC은 방금 ARP로 알아낸 “다음 홉(공유기)”의 MAC이다.
    
- 이렇게 만들어진 프레임이 네트워크 카드(NIC)를 통해 전송된다.
    

### 3.6 라우터들은 “목적지 IP”를 보고 다음으로 넘긴다 (Longest Prefix Match)

패킷이 공유기에 도착하면, 공유기(라우터)는 링크 계층을 벗겨 IP 패킷을 보고, 목적지 IP에 대해 라우팅 테이블을 조회한다.  
이때 라우터는 보통 **Longest Prefix Match(가장 구체적으로 맞는 경로 선택)** 규칙으로 다음 홉을 결정한다.

- 그리고 IP TTL을 1 줄이고,
    
- 다음 링크로 다시 프레임을 만들어 보내며,
    
- 이런 과정이 여러 홉(hop)을 거쳐 반복된다.
    

### 3.7 (필요하면) MTU 때문에 조각화/PMTUD 이슈가 생긴다

네트워크에는 한 번에 실어 보낼 수 있는 최대 크기(**MTU**)가 있다.  
만약 패킷이 어떤 구간의 MTU보다 크면 문제가 생긴다.

- 예전 방식: 라우터가 패킷을 조각(fragment)으로 나눠 전달(조각화)
    
- 현대 운영: 조각화를 피하고 **Path MTU Discovery(PMTUD)**로 “안 깨지는 크기”를 맞추는 방식이 흔함
    
- 방화벽/정책 때문에 PMTUD 관련 ICMP가 막히면 “특정 사이트만 느리거나 끊김” 같은 현상이 나오기도 함
    

> [!note] 용어 정리 — MTU
> 
> - **MTU**: 한 링크에서 한 번에 보낼 수 있는 최대 프레임/패킷 크기
>     
> - MTU 문제가 있으면 “연결은 되는데 특정 큰 요청에서만 멈춤/깨짐” 같은 형태로 나타날 수 있다
>     

### 3.8 목적지 서버에 도착하면, IP는 “상위 계층(TCP/UDP)”에 넘긴다

목적지 서버는 자신의 IP로 온 패킷을 받으면, IP 헤더의 Protocol 값을 보고 TCP/UDP로 전달한다.  
그 다음은 TCP가 포트(예: 443)로 소켓을 찾아 전달하고, 그 위에서 TLS/HTTP가 동작한다.  
즉, IP는 “목적지 컴퓨터까지 보내는” 책임을 지고, “어떤 프로세스(서비스)에게 전달할지”는 TCP/UDP의 포트가 담당한다.

---

## 4) 내가 직접 확인할 수 있게 재현 절차(macOS)

아래는 macOS에서 “내 IP가 무엇이고, 어떤 경계(/24 등)로 묶이며, 실제로 어디로 보내는지(게이트웨이/ARP/홉)”를 눈으로 확인하는 절차다.

### 4.1 내 IPv4 주소와 서브넷 마스크 확인

**명령어/입력값**

```bash
ipconfig getifaddr en0
ifconfig en0 | egrep "inet |netmask"
```

**예상 출력(예시 형태)**

- `ipconfig getifaddr en0`
    
    - `192.168.0.10`
        
- `ifconfig ...`
    
    - `inet 192.168.0.10 netmask 0xffffff00 broadcast 192.168.0.255`
        

**체크 포인트**

- `inet`이 내 IPv4다.
    
- `netmask 0xffffff00`은 흔히 **/24**에 해당한다.
    
    - 참고로 자주 보는 매핑:
        
        - `0xffffff00` → /24
            
        - `0xffff0000` → /16
            
- 이 값을 알아야 “목적지가 같은 네트워크인지/밖인지”를 판단할 수 있다.
    

> [!note] 용어 정리 — netmask가 16진수로 보이는 이유
> 
> - macOS `ifconfig`는 마스크를 `0xffffff00` 같은 16진수로 보여주는 경우가 많다.
>     
> - 핵심은 “1로 채워진 비트 개수 = /숫자”라는 점이다.
>     

---

### 4.2 내 기본 게이트웨이(기본 경로) 확인

**명령어/입력값**

```bash
route -n get default
# 또는
netstat -rn | head
```

**예상 출력(예시 형태)**

- `route -n get default`
    
    - `gateway: 192.168.0.1`
        
    - `interface: en0`
        

**체크 포인트**

- `gateway`가 기본 게이트웨이(대부분 공유기)다.
    
- “로컬 네트워크 밖 목적지”는 보통 이 게이트웨이로 간다.
    

---

### 4.3 특정 목적지 IP로 갈 때 “어느 인터페이스/게이트웨이로 가는지” 확인

**명령어/입력값**

```bash
route -n get 93.184.216.34
```

**예상 출력(예시 형태)**

- `gateway: 192.168.0.1`
    
- `interface: en0`
    

**체크 포인트**

- 이 출력은 “내 PC가 저 IP로 패킷을 보낼 때 실제로 선택한 경로”다.
    
- 만약 VPN을 쓰는 중이면 `interface`가 `utun...` 같은 것으로 바뀌기도 한다(그럼 경로가 달라진 것).
    

---

### 4.4 ARP가 실제로 동작하는지(다음 홉 MAC을 찾았는지) 확인

**명령어/입력값**

```bash
arp -a | head
ping -c 1 192.168.0.1
arp -a | head
```

**예상 출력(예시 형태)**

- `arp -a`에 이런 줄이 보인다:
    
    - `? (192.168.0.1) at aa:bb:cc:dd:ee:ff on en0 ...`
        

**체크 포인트**

- `192.168.0.1`(게이트웨이)에 대해 `at aa:bb:...`처럼 MAC이 붙어 있으면  
    → “IP→MAC 해석(ARP)이 됐고, ARP 캐시에 저장되었다”는 뜻이다.
    
- ARP가 안 되면 “같은 Wi-Fi에 있는데도 외부로 못 나감” 같은 증상이 쉽게 나온다.
    

---

### 4.5 홉(라우터)을 몇 번 거치는지, TTL이 왜 필요한지 확인 (traceroute)

**명령어/입력값**

```bash
traceroute 93.184.216.34
```

**예상 출력(예시 형태)**

- `1 192.168.0.1 ... ms`
    
- `2 ...`
    
- `3 ...`
    
- ...
    
- 마지막 줄에 목적지 근처 주소가 나온다
    

**체크 포인트**

- 줄 번호가 “몇 번째 라우터(홉)를 지나는지”를 의미한다.
    
- traceroute는 TTL을 1부터 늘려가며 “어디까지 가는지”를 관측하는 방식이라,  
    IP TTL이 “무한 루프 방지 장치”로 왜 필요한지 감각이 잡힌다.
    

---

### 4.6 실제로 IP가 들어간 트래픽을 눈으로 보기 (tcpdump)

**명령어/입력값(주의: sudo 필요)**

```bash
sudo tcpdump -n -i en0 host 93.184.216.34
```

**예상 출력(예시 형태)**

- `IP 192.168.0.10.52344 > 93.184.216.34.443: Flags [S], ...`
    
- `IP 93.184.216.34.443 > 192.168.0.10.52344: Flags [S.], ...`
    

**체크 포인트**

- `IP 출발지.포트 > 목적지.포트` 형태로 보인다.
    
- 여기서 “IP는 목적지 컴퓨터까지”, “포트는 그 컴퓨터 안의 서비스까지”라는 분리가 실제로 보인다.
    

---

## 5) 흔한 오해 3개 + 반례(현실 예시)

### 오해 1) “IP는 전 세계에서 기기마다 유일한 번호다”

**반례(현실 예시)**: 집 공유기 아래 PC가 `192.168.0.10`이고, 회사 네트워크 PC도 `192.168.0.10`일 수 있다.  
이 주소들은 **사설 IP**라서 전 세계적으로 유일할 필요가 없다. 인터넷으로 나갈 때는 보통 공유기/방화벽이 **NAT**로 공인 IP로 바꿔서 통신한다. 즉 “내 PC의 IP”라고 말할 때는 **사설 IP인지 공인 IP인지**를 구분해야 한다.

### 오해 2) “IP만 알면 서비스에 접속할 수 있다”

**반례(현실 예시)**: 같은 서버 IP(예: `203.0.113.10`)에 웹(443), API(8443), DB(3306) 등 여러 서비스가 동시에 열릴 수 있다.  
접속은 보통 **IP + 포트**가 한 세트다. 그리고 HTTPS에서는 같은 IP/443에서도 SNI/Host 헤더에 따라 서로 다른 사이트가 서비스되기도 한다. 즉 “IP만”으로는 서비스가 고정되지 않는다.

### 오해 3) “IP의 네트워크 부분은 항상 앞 24비트다”

**반례(현실 예시)**: 회사 내부망은 `10.20.0.0/16`, 개발용 VPC는 `10.0.0.0/20`, 작은 망은 `192.168.10.0/27`처럼 다양한 경계를 쓴다.  
‘앞 24비트’는 **/24라는 흔한 경우**일 뿐이고, 실제 경계는 **CIDR(/숫자)** 또는 **서브넷 마스크**로 정해진다. 이걸 모르면 “같은 대역인데 왜 직접 통신이 안 되지?” 같은 판단을 자주 틀린다.