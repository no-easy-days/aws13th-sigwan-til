> [!note] DNS 결론
> **인터넷의 전화번호부**  
> DNS는 **도메인 이름(예: `example.com`)을 IP/서버 정보(A/AAAA/CNAME/MX 등)로 바꿔주는 분산 조회 시스템**이다.  
> 실무에선 “왜 접속이 안 되지?”의 많은 원인이 **DNS 캐시(TTL), 잘못된 레코드, 잘못된 리졸버 설정**에서 나온다.  
> 핵심은 **(1) 어디서 캐시되고 (2) 어떤 서버(리졸버/권한서버)가 답했는지**를 분리해서 보는 것.

---

# 1) DNS (Domain Name System) 

DNS(Domain Name System)는 사람이 읽기 쉬운 **도메인 이름**(예: `google.com`)을, 컴퓨터가 실제 통신에 사용하는 **IP 주소**(예: `142.250…`)로 변환해 주는 **분산형 네이밍 시스템**이다. 웹 브라우저나 모바일 앱, 서버 프로그램은 네트워크 연결을 시작하기 전에 먼저 “어디로 접속해야 하는가”를 알아야 하는데, 이때 DNS를 통해 목적지의 IP(또는 연결에 필요한 레코드)를 얻는다. 실무 관점에서 DNS는 “이름(도메인) ↔ 번호(IP)”를 연결해 주는 장치이며, 사용자는 IP를 외우지 않아도 도메인만으로 서비스를 이용할 수 있게 된다.

> [!note] 용어 정리 — DNS의 한 줄 정의
> 
> - **DNS**: 도메인 이름을 IP 주소(또는 레코드)로 바꿔주는 시스템
>     
> - **이름 해석(Name Resolution)**: “도메인 → IP 변환” 작업을 의미함
>     

---

## 1. DNS가 해결하는 문제(왜 필요한가)

인터넷에서 통신의 실제 목적지는 IP 주소로 표현된다. 그러나 IP는 숫자 조합이라 사람이 외우기 어렵고, 서비스 운영 과정에서 변경될 수도 있다. 반대로 도메인은 사람이 기억하기 쉬운 문자열이며, 서비스/브랜드 단위로 비교적 안정적으로 유지된다. DNS는 이 둘의 간극을 메우기 위해 존재한다. 즉 사용자는 `google.com`처럼 기억하기 쉬운 이름만 입력하면 되고, 시스템은 DNS를 통해 해당 이름이 가리키는 IP를 찾아 접속을 수행한다. 이 구조 덕분에 서비스는 인프라(IP, 서버)를 교체하면서도 사용자에게는 동일한 도메인 경험을 제공할 수 있다.

> [!note] 비유(유지) — 인터넷의 전화번호부
> 
> - 사람은 이름(도메인)으로 찾고, 컴퓨터는 번호(IP)로 연결한다.
>     
> - DNS는 “이름을 넣으면 번호를 알려주는” 전화번호부 역할을 한다.
>     

---

## 2. 도메인 이름은 어떻게 구성되는가(계층 구조)

도메인은 **계층적 구조**를 가진다. 사람은 보통 왼쪽부터 읽지만, DNS의 해석은 기본적으로 **오른쪽에서 왼쪽 방향**으로 상위 → 하위로 진행된다고 이해하면 된다. 예를 들어 `www.jeff-coding.com`이라는 이름을 보면, 가장 오른쪽의 `com`이 상위 분류(TLD)이고, 그 왼쪽의 `jeff-coding`이 해당 TLD 아래의 고유 이름(2차 도메인), 가장 왼쪽의 `www`는 서비스 내부에서 용도를 구분하기 위해 붙는 서브도메인이다. 또한 모든 도메인의 최상단에는 보이지 않는 루트(`.`)가 존재한다고 설명된다.

> [!note] 용어 정리 — 도메인 구조
> 
> - **루트(Root) `.`**: DNS 계층의 최상위. 엄밀히는 모든 도메인 끝에 `.`이 있다고 본다.
>     
> - **TLD(Top-Level Domain)**: `.com`, `.org`, `.kr` 같은 최상위 도메인
>     
> - **SLD(Second-Level Domain)**: `jeff-coding`처럼 TLD 아래의 고유 이름(조직/서비스가 등록)
>     
> - **서브도메인(Subdomain)**: `www`, `api`, `blog`처럼 용도별로 나눠 쓰는 접두 영역
>     
> - **FQDN**: 끝의 `.`까지 포함한 완전한 도메인 표기(예: `www.jeff-coding.com.`)
>     

---

## 3. 주소창에 도메인을 입력하면 실제로 어떤 일이 일어나는가

사용자가 브라우저 주소창에 `google.com`을 입력하면, 브라우저는 바로 통신을 시작하는 것이 아니라 먼저 “이 도메인이 가리키는 IP는 무엇인가”를 확인한다. 일반적으로 이 과정은 OS(운영체제)의 이름 해석 기능을 통해 수행되며, OS는 설정된 DNS 리졸버(재귀 리졸버 등)를 활용하여 도메인에 해당하는 레코드를 조회한다. DNS가 A/AAAA 같은 레코드로 IP를 반환하면, 그제서야 브라우저는 해당 IP로 TCP 연결을 생성하고, HTTPS라면 TLS 협상을 진행한 뒤, HTTP 요청을 전송한다. 즉 DNS는 **연결을 시작하기 위한 목적지 정보(IP)를 마련하는 단계**로서 기능한다.

> [!note] 용어 정리 — A/AAAA 레코드
> 
> - **A 레코드**: 도메인 → IPv4 주소로 연결
>     
> - **AAAA 레코드**: 도메인 → IPv6 주소로 연결
>     
> - 브라우저는 환경에 따라 A 또는 AAAA를 사용해 접속한다.
>     

---

## 4. 최소 핵심 용어(4개)로 다시 잡기

DNS를 이해할 때 가장 혼동이 적은 최소 단위는 다음 네 가지다.

- **도메인(Domain Name)**: 사람이 입력하는 이름(예: `google.com`)
    
- **IP 주소(IP Address)**: 네트워크가 연결하는 대상 주소(예: `142.250…`)
    
- **리졸버(Resolver)**: 도메인을 IP로 바꾸기 위해 DNS 질의를 수행하고 결과를 돌려주는 역할(보통 OS/재귀 리졸버 포함)
    
- **레코드(Record)**: DNS에 저장된 실제 매핑 정보(A/AAAA/CNAME/NS 등)
    

> [!note] 용어 정리 — “리졸버”가 헷갈릴 때
> 
> - 리졸버는 “DNS에 물어보고 답을 가져오는 쪽”이다.
>     
> - 권한 DNS는 “정답을 보관하고 제공하는 쪽”이다.
>     
> - 둘을 구분하면 구조가 깔끔해진다.
>     

---


---

# 2) 왜 그렇게 설계됐는지(철학/트레이드오프)

## 1. HOSTS.TXT 중심 운영의 한계에서 출발한다 (1960s–초기 1980s)

인터넷(ARPANET 포함) 초기에는 이름–주소 매핑이 **HOSTS.TXT**와 같은 단일 텍스트 파일로 관리·배포되는 방식이 널리 사용된다. 이 파일은 중앙 기관에서 유지·배포되는 구조였고, 참여 호스트 증가에 따라 업데이트 지연, 충돌, 배포 비용이 누적되며 확장성 문제가 구조적으로 드러난다. 
이 시점의 문제는 “이름 체계는 필요하나, 이를 단일 지점에서 관리하는 방식은 규모에서 붕괴한다”는 결론으로 이어진다.

## 2. ‘분산/계층’과 ‘위임(Delegation)’이 설계 목표로 등장한다 (1983–1986)

1983년 Mockapetris의 초기 DNS 문서(RFC 882/883)는 **도메인 스타일 이름(domain style names)** 과 이를 제공하는 프로토콜/서버 구조를 제시한다. 이는 단일 파일 배포 모델의 병목을 해소하기 위해, 이름 공간을 계층화하고 관리 책임을 분산시키는 방향으로 설계가 전환되는 단계로 이해된다.
이후 1986년의 관찰 문서(RFC 973) 등은 실제 운영 경험을 반영하며, 분산 시스템으로서의 DNS가 현실 네트워크 위에서 동작하기 위한 고려사항들이 축적되는 흐름으로 이어진다. 

## 3. 표준 확립과 함께 ‘캐시(TTL)’가 성능 철학으로 고정된다 (1987)

1987년 RFC 1034/1035는 DNS의 개념 및 구현을 정식 표준으로 정리하면서, **존(zone)·위임·리졸버/네임서버 역할 분리** 등 현대 DNS의 골격을 확정한다. 이 과정에서 DNS는 HOSTS.TXT를 대체하는 체계로 명시된다. 
동시에, 전 세계 질의를 매번 상위 계층(루트/TLD/권한)까지 재귀적으로 해석하는 모델은 비용이 과도하므로, **캐시를 전제로 하는 운영 모델**이 사실상 필수로 자리 잡는다. 이때 **TTL(Time To Live)** 은 “캐시 가능한 기간”을 제어하는 핵심 메커니즘으로 기능하며, 성능과 부하를 통제하는 철학으로 정착한다. 

## 4. 대규모 트래픽 시대에 ‘캐시의 확장(음수 캐시)’이 운영 철학을 강화한다 (1990s–1998)

웹 확산과 함께 질의량이 급증하면, 단순 캐시만으로는 네트워크 비용을 충분히 억제하기 어렵다. 이에 1998년 RFC 2308은 **Negative Caching(부정 응답 캐시)**를 통해 “존재하지 않는 이름(NXDOMAIN 등)에 대한 반복 질의”를 줄이는 방향을 제도화한다. 이는 캐시를 단순 최적화가 아니라 “대규모 운영을 가능하게 하는 핵심 장치”로 확장시키는 흐름으로 이어진다.

## 5. 보안/무결성 요구가 커지며 ‘DNSSEC’로 철학이 확장된다 (2000s–2005)

DNS는 본질적으로 분산 캐시 구조를 갖기 때문에, 응답 위·변조 및 캐시 오염에 대한 우려가 지속된다. 이에 2005년 DNSSEC 표준군(RFC 4033/4034/4035)은 DNS에 **데이터 기원 인증(data origin authentication)** 과 **무결성(data integrity)** 을 추가하는 방향으로 설계 철학을 확장한다. 즉, “빠르고 분산된 이름 해석”에서 나아가 “신뢰 가능한 이름 해석”을 요구하는 흐름으로 발전한다. 
다만 이 단계는 키 관리·서명 운영 등으로 인해 운영 복잡도가 증가하는 트레이드오프를 동반하며, 보안 강화를 위해 운영 비용을 수용하는 방향으로 이어진다.

## 6. 프라이버시 요구가 커지며 ‘암호화 전송(DoT/DoH)’으로 이어진다 (2010s–2016/2018)

전통적인 DNS 질의는 네트워크 상에서 관찰·변조될 여지가 있다는 점에서 프라이버시 문제로 확장된다. 2016년 RFC 7858은 **DNS over TLS(DoT)** 를 통해 DNS 트랜잭션에 대한 프라이버시를 제공하도록 정리한다.   
2018년 RFC 8484는 **DNS over HTTPS(DoH)** 를 표준화하며, DNS 질의–응답을 HTTPS 교환으로 매핑하고 TLS를 통해 기밀성과 무결성을 제공하는 방향으로 확장된다. 
이 흐름은 “정확한 이름 해석” → “확장 가능한 이름 해석” → “신뢰 가능한 이름 해석” → “관찰에 강한 이름 해석”으로 철학이 단계적으로 확대되는 과정으로 정리된다.

## 7. 트레이드오프는 철학의 반대편에서 구조화된다

상기 발전 과정에서 트레이드오프 또한 누적적으로 구조화된다.

- **변경 전파 지연**은 TTL 캐시 철학의 필연적 결과로 이어진다(성능을 얻는 대신 전파 즉시성을 포기한다). 
- **디버깅 복잡성**은 캐시 계층(로컬/리졸버/권한)과 위임 구조가 확장되면서 증가한다(어디서 잘못되었는지 층이 늘어난다). 
- **보안/무결성 이슈**는 DNSSEC 및 DoT/DoH로 보완되나, 그 자체로 운영 복잡도와 정책/관측의 부담이 추가되는 방향으로 이어진다. 

---

# 3) DNS 이름 해석의 내부 동작(파일·캐시·네트워크)

브라우저에서 `https://example.com`을 입력하는 순간, 사용자는 “웹사이트에 접속한다”고 느끼지만, 컴퓨터 입장에서는 먼저 해결해야 할 선행 과제가 존재한다. 브라우저가 실제 서버와 통신하려면, 우선 사람이 읽는 문자열인 도메인(`example.com`)을 네트워크가 이해하는 숫자 주소인 IP로 바꿔야 한다. 이 변환 과정이 바로 DNS가 담당하는 역할이며, 이 단계가 완료되어 IP가 확보된 이후에야 TCP 연결이 생성되고(연결 통로), HTTPS라면 TLS 협상이 수행되며(암호화 통로), 마지막으로 HTTP 요청이 전송된다. 다시 말해 DNS는 “도메인 이름을 목적지 정보(IP/레코드)로 바꾸는 단계”까지를 책임지고, 경로(`/login`)나 요청 내용 같은 것은 그 이후 계층에서 처리된다.

> [!note] 용어 정리 — 도메인과 IP
> 
> - **도메인(Domain)**: 사람이 읽기 쉬운 주소 이름(예: `example.com`)
>     
> - **IP 주소(IP Address)**: 컴퓨터가 네트워크에서 서로를 찾는 숫자 주소(예: `93.184.216.34`)
>     
> - DNS는 “도메인 이름을 IP(또는 연결 대상 레코드)로 바꿔주는 시스템”이다.
>     

---

## 1) 브라우저는 OS에 “이 도메인의 IP를 알려달라”고 요청한다

사용자가 주소창에 `https://example.com`을 입력하면, 브라우저는 곧바로 인터넷 어딘가로 패킷을 날리지 않는다. 먼저 “내가 연결해야 할 대상의 IP가 무엇인지”를 알아야 하기 때문이다. 따라서 브라우저는 운영체제(OS)가 제공하는 이름 해석 기능을 호출하여 `example.com`에 대한 주소 정보를 요청한다. 이때 핵심은 브라우저가 대개 DNS 서버와 직접 대화하는 것이 아니라, OS의 이름 해석 경로(설정, 캐시 정책, 우선순위 규칙)를 거쳐 결과를 얻는다는 점이다. 따라서 동일한 브라우저 동작이라도 OS 설정이나 네트워크 환경에 따라 실제 질의 경로가 달라질 수 있다.

> [!note] 용어 정리 — 이름 해석과 리졸버
> 
> - **이름 해석(Name Resolution)**: 도메인 이름을 IP 주소로 변환하는 작업
>     
> - **리졸버(Resolver)**: 이름 해석을 수행하는 구성요소(보통 OS와 네트워크 설정에 포함)
>     
> - 쉽게 말해, “도메인을 IP로 바꿔주는 담당자”가 리졸버다.
>     

---

## 2) OS는 먼저 로컬에서 즉시 해결할 수 있는지 확인한다(/etc/hosts)

운영체제는 요청을 받으면, 곧바로 외부 DNS 서버로 질의를 보내기 전에 “내 컴퓨터 안에 이미 정답이 있는가”를 먼저 검사한다. 대표적인 검사 대상은 `/etc/hosts` 파일이다. `/etc/hosts`는 도메인과 IP를 사람이 직접 적어둘 수 있는 정적 매핑의 일종이며, 특정 도메인에 대한 항목이 여기에 존재하면 OS는 DNS 질의를 수행하지 않고 해당 IP를 즉시 반환할 수 있다. 이 때문에 실무에서는 hosts 파일에 잘못된 항목이 남아 “특정 사이트만 접속이 되지 않는” 유형의 장애가 발생하기도 한다.

또한 macOS 환경에서는 이름 해석 및 캐시 관리 과정에 `mDNSResponder` 같은 시스템 구성요소가 관여한다. 그 결과 사용자는 “내가 DNS를 물어봤다”고 생각하지만 실제로는 로컬에서 캐시가 반환되었거나, 반대로 로컬에서 해결되지 않아 네트워크 질의가 나간 상황일 수 있다. 따라서 “질의가 실제로 외부로 나갔는지”를 확인할 때는 OS 레벨의 도구(`scutil`, `dig`)로 관측하는 것이 가장 확실하다.

> [!note] 용어 정리 — 정적 매핑과 mDNSResponder
> 
> - **정적 매핑(Static Mapping)**: 변환 규칙을 미리 고정해 파일 등에 기록해 두는 방식
>     
> - `/etc/hosts`는 정적 매핑의 대표 사례다.
>     
> - **mDNSResponder**: macOS에서 DNS 질의/캐시/로컬 네임 해석에 관여하는 시스템 프로세스
>     
> - 쉽게 말해 “macOS DNS 처리의 핵심 담당자”로 이해하면 된다.
>     

---

## 3) 로컬 캐시를 확인한다(이전에 찾았던 결과가 남아 있는가)

`/etc/hosts`에서 해결되지 않으면, OS는 다음으로 캐시를 확인한다. 캐시는 이전에 한 번 조회했던 결과를 일정 시간 저장해 두었다가, 같은 도메인에 대한 요청이 다시 들어오면 빠르게 응답하기 위한 장치다. 예를 들어 사용자가 방금 전에 `example.com`에 접속했거나, 시스템이 배경에서 해당 도메인을 조회한 적이 있다면, OS 또는 애플리케이션 계층의 캐시에서 즉시 IP가 반환될 수 있다. 이때는 네트워크 질의가 발생하지 않으므로 속도가 빠르다. 다만 캐시는 “일시적으로 과거의 결과를 유지하는 장치”이기도 하므로, 도메인의 IP가 바뀐 직후에는 캐시된 옛 값이 남아 있어 혼란을 유발할 수 있다.

> [!note] 용어 정리 — 캐시
> 
> - **캐시(Cache)**: “다시 쓰려고 임시로 저장해 둔 결과”
>     
> - 장점: 빠르다(네트워크 질의를 줄인다).
>     
> - 단점: 바뀐 값을 즉시 반영하지 못하고 과거 값이 남아 있을 수 있다.
>     

---

## 4) 로컬에서 해결되지 않으면 재귀 리졸버에게 질의한다(대신 찾아오는 역할)

로컬 정적 매핑과 로컬 캐시에서 해결되지 않는 경우, OS는 네트워크 설정에 지정된 DNS 서버로 질의를 전송한다. 여기서 “DNS 서버”는 보통 재귀 리졸버(Recursive Resolver)를 의미한다. 재귀 리졸버는 사용자(클라이언트)를 대신하여 루트 → TLD → 권한 서버를 순차적으로 따라가며 정답을 찾아오는 서버다. 회사 네트워크에서는 사내 DNS가, 가정 환경에서는 공유기/ISP DNS가, 또는 사용자가 직접 설정한 공용 리졸버(예: 1.1.1.1, 8.8.8.8)가 재귀 리졸버 역할을 수행한다.

재귀 리졸버 역시 요청을 받으면 가장 먼저 자신의 캐시를 확인한다. 이미 최근에 누군가가 동일한 도메인을 조회하여 캐시가 남아 있다면, 즉시 응답한다. 반대로 캐시에 답이 없다면, 재귀 리졸버는 DNS의 계층 구조를 따라가며 정답을 구성한다. 먼저 루트 네임서버로부터 `com`을 담당하는 TLD 네임서버 목록을 얻고, 그 다음 TLD 네임서버로부터 `example.com`의 권한 네임서버(NS)를 얻으며, 마지막으로 권한 네임서버에게 A/AAAA 레코드(IP)를 질의하여 최종 결과를 확보한다. 이 흐름에서 중요한 개념은 “위임(delegation)”이다. 상위 영역이 하위 영역의 관리를 특정 네임서버 집합에게 맡기는 구조 덕분에 전 세계 도메인 관리가 분산 가능해지고, 동시에 계층적 조회가 가능해진다.

> [!note] 용어 정리 — 재귀 리졸버, 권한 DNS, NS, 위임
> 
> - **재귀 리졸버(Recursive Resolver)**: 사용자를 대신해 DNS 계층을 따라 정답을 찾아오는 DNS 서버
>     
> - **네임서버(Name Server)**: DNS 질의에 답하는 서버
>     
> - **권한 네임서버(Authoritative DNS)**: 특정 도메인의 “최종 정답”을 관리하는 서버
>     
> - **NS 레코드**: “이 도메인의 권한 네임서버가 누구인지”를 알려주는 레코드
>     
> - **위임(Delegation)**: “이 영역의 관리는 이 네임서버들이 맡는다”라고 책임을 넘기는 구조
>     

---

## 5) 정답을 받으면 TTL 동안 캐시하고 클라이언트에 반환한다

권한 네임서버는 정답을 응답할 때 대개 TTL(Time To Live) 값을 함께 포함한다. TTL은 “이 응답을 캐시에 얼마나 오래 저장해도 되는가”를 의미한다. 재귀 리졸버는 응답을 받으면 TTL이 허용하는 기간 동안 캐시에 저장하고, 그 결과를 OS(클라이언트)에게 전달한다. OS 역시 필요에 따라 로컬 캐시에 저장할 수 있다.

이 구조는 성능 면에서 매우 효율적이다. 많은 사용자가 같은 도메인을 반복해서 접속하는 현실에서, 매번 루트부터 권한 서버까지 확인하는 것은 비효율적이며 지연과 부하를 급격히 증가시킨다. TTL 기반 캐시는 이를 완화한다. 다만 이 효율성은 “전파 지연”이라는 비용을 동반한다. 도메인의 IP를 변경하더라도, TTL이 남아 있는 캐시가 존재하는 동안 일부 환경에서는 이전 IP가 계속 관측될 수 있다. 이 현상은 “DNS가 느리다”라기보다 “캐시 설계의 필연적인 결과”로 이해하는 것이 정확하다.

> [!note] 용어 정리 — TTL과 전파 지연
> 
> - **TTL(Time To Live)**: “캐시에 저장해도 되는 최대 시간”
>     
> - 예: TTL=300이면 5분 동안 캐시 사용 가능
>     
> - **전파 지연**: DNS 레코드를 변경했는데도, 캐시 때문에 일정 시간 동안 옛 값이 관측되는 현상
>     

---

## 6) DNS가 끝나면, 그 다음은 TCP/TLS/HTTP가 처리한다

DNS 단계가 종료되면 브라우저는 확보한 IP로 실제 연결을 시도한다. 먼저 TCP 연결을 생성하여 통신 경로를 확보하고, HTTPS라면 TLS 핸드셰이크를 통해 암호화 통로를 설정한 뒤, HTTP 요청을 전송한다. 여기서 강조할 점은 DNS가 URL의 경로(`/login`)나 요청 본문, 로그인 정보 같은 것을 처리하지 않는다는 사실이다. DNS는 오직 “어느 서버로 갈 것인가”를 결정하는 단계이며, “서버에 무엇을 요청할 것인가”는 HTTP 계층에서 다루어진다.

> [!note] 용어 정리 — TCP, TLS, HTTP
> 
> - **TCP**: 데이터를 안정적으로 주고받기 위한 연결 방식(연결을 만든 뒤 통신)
>     
> - **TLS**: HTTPS에서 암호화/인증을 제공하는 보안 계층(암호화 통로)
>     
> - **HTTP**: 웹 요청/응답 규칙(GET/POST 등)
>     

---

# 4. 재현 절차(macOS) — “내 눈으로 확인”하는 방법(서술형)

DNS는 “개념”으로만 이해하면 쉽게 추상화되지만, 실제로는 시스템 설정과 캐시 계층이 얽혀 있어 관측이 중요하다. 따라서 아래 절차는 사용자가 현재 자신의 macOS 환경에서 DNS가 어떻게 동작하는지 직접 확인할 수 있도록 구성된다.

먼저, 시스템이 어떤 DNS 서버(재귀 리졸버)에 질의하는지 확인해야 한다. 이를 위해 `scutil --dns`를 실행하면 현재 활성화된 리졸버 설정이 출력되며, 여기서 `nameserver[...]`에 표시되는 IP가 실제 질의 대상이다. 이 값이 회사 DNS인지, 공유기인지, 공용 리졸버인지에 따라 이후의 문제 양상이 달라질 수 있으므로, 디버깅의 기준점으로 삼는다.

> [!note] 명령어
> 
> ```bash
> scutil --dns | head -n 80
> ```
> 
> **체크 포인트**: `nameserver[...] : x.x.x.x`가 “내가 DNS를 묻는 대상”이다.

다음으로, `dig example.com A`를 통해 기본 질의를 수행하면 정답(IP)뿐 아니라 TTL, 그리고 어떤 서버가 답했는지(`SERVER:`)까지 관측할 수 있다. `ANSWER SECTION`의 TTL은 캐시 관점에서 매우 중요한 지표다. “바꿨는데 안 바뀌는” 문제의 상당수는 TTL과 캐시 계층에서 발생한다.

> [!note] 명령어
> 
> ```bash
> dig example.com A
> ```
> 
> **체크 포인트**: `ANSWER SECTION`의 `TTL`, 그리고 `SERVER:`가 누구인지 확인한다.

DNS의 위임 구조를 직접 확인하려면 `dig ... +trace`가 유용하다. 이 옵션은 루트에서 시작하여 TLD를 거쳐 권한 서버로 이어지는 과정을 출력한다. 중간에 NS가 바뀌는 지점이 위임이 발생하는 구간이며, 마지막에 A 레코드를 반환하는 서버가 권한 DNS임을 확인할 수 있다.

> [!note] 명령어
> 
> ```bash
> dig example.com A +trace
> ```
> 
> **체크 포인트**: 중간의 NS 변화(위임), 마지막 응답 서버(권한 DNS)를 본다.

또한 동일 도메인을 서로 다른 리졸버에 질의하면, 문제가 내 환경/내 리졸버에 한정된 것인지, 특정 리졸버 정책/캐시 때문인지 분리할 수 있다. 예를 들어 1.1.1.1과 8.8.8.8에 각각 질의해 결과가 달라진다면 캐시/정책 차이를 의심할 근거가 된다.

> [!note] 명령어
> 
> ```bash
> dig @1.1.1.1 example.com A
> dig @8.8.8.8 example.com A
> ```
> 
> **체크 포인트**: 결과 차이는 캐시/정책 차이 가능성을 의미한다.

마지막으로 `/etc/hosts`가 DNS보다 우선하는지 확인하려면 테스트 도메인을 hosts에 추가한 뒤 `ping`으로 확인할 수 있다. 다만 이 테스트는 시스템 전체에 영향을 줄 수 있으므로, 실험 후에는 반드시 원복해야 한다.

> [!note] 명령어(주의)
> 
> ```bash
> sudo sh -c 'echo "127.0.0.1 myfake.test" >> /etc/hosts'
> ping -c 1 myfake.test
> ```
> 
> **체크 포인트**: `PING myfake.test (127.0.0.1)`가 나오면 hosts 우선이 확인된다.  
> **주의**: 테스트 후 `/etc/hosts`에서 추가한 줄을 삭제하여 원복한다.

---

# 5. 흔한 오해와 반례(서술형)

DNS는 URL 전체를 처리한다고 오해되곤 하나, 실제로는 도메인 이름을 IP/레코드로 변환하는 역할까지만 담당한다. 따라서 `/login` 같은 경로는 DNS가 아니라 HTTP 서버가 처리한다. 또한 DNS 레코드를 변경하면 전 세계가 즉시 반영된다고 생각하기 쉽지만, TTL 기반 캐시가 존재하므로 일정 시간 동안 옛 값이 관측되는 것은 정상적인 현상이다. 마지막으로 DNS가 항상 UDP 53만 사용한다고 단정하기도 하지만, 응답 크기나 환경에 따라 TCP 53이 사용될 수 있으며, 프라이버시 목적의 DoH(443), DoT(853) 등 암호화 전송 방식도 활용된다.
