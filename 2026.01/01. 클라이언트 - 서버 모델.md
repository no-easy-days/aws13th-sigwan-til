> [!note] 클라이언트–서버 모델 
> 클라이언트는 “요청을 만드는 쪽”, 서버는 “요청을 처리해 응답을 내는 쪽”이다.  
> 실무에선 **UI/기기 다양성은 클라이언트**, **데이터/비즈니스 규칙/권한은 서버**에 두면 운영·확장이 쉽다.  
> 핵심은 **요청–응답 계약(API)**을 안정적으로 유지하는 것이다.

# 0) 어원

## Client (클라이언트) 어원

- 라틴어 cliēns / clientem에서 온 말로, 고대 로마의 **“후원자(patron)를 따르는 사람/의뢰인/보호를 받는 사람”(follower, retainer)** 의미가 핵심

- 어원 설명에서 _clināre_(“기울다/기대다, to lean”)와의 연관이 자주 언급돼. 즉 “누군가에게 기대는/의지하는 관계” 뉘앙스가 있었고, 현대의 “서비스를 요청/의뢰하는 쪽” 의미로 자연스럽게 이어진 것
## Server (서버) 어원

- 영어 **server**는 본래 “serve(섬기다/제공하다)하는 사람/것”이라는 뜻으로, 14세기 후반부터 “시중드는 사람”, “무언가를 제공하는 주체” 의미로 쓰임
    
- 컴퓨팅에서의 “서버”는 “요청을 받아 처리하고 결과를 제공하는 쪽”이라는 일상 의미(serve)의 확장

## (컴퓨터 용어로서) client–server가 붙은 역사적 맥락

- 네트워크 초창기 문서들에서 **server-host / user-host** 같은 표현이 등장하고, 이런 대비가 오늘날의 client–server 관점으로 이어졌다고 

---

# 1) 동작 원리 

- 클라이언트–서버 모델은 **클라이언트가 “요청(Request)”을 보내면**, 서버가 그 요청을 **처리(로직 실행/DB 조회 등)** 해서 **응답(Response)** 을 돌려주는 **요청–응답 구조**

- 클라이언트-서버 모델은 **요청(Request)** 과 **응답(Response)** 의 반복
-
- 이 과정은 보통 네트워크(예: 인터넷) 위에서 **HTTP 같은 프로토콜 규칙**에 따라 메시지를 주고받으면서 동작

---

# 2) 왜 그렇게 설계됐는지(철학/트레이드오프)

## 시간순으로 보는 클라이언트–서버 설계 이유(철학)와 손해(트레이드오프)

### 1) 1950s–1960s: 메인프레임 + 터미널(중앙집중이 당연했던 시대)

- **왜 이렇게 했나(철학의 씨앗)**  
    컴퓨팅 자원이 매우 비싸고 희소해서, 연산/데이터를 **한 곳(메인프레임)** 에 두고 여러 사용자가 **터미널로 접속**하는 게 효율적이었음.  
    → 자연스럽게 “중앙 통제(데이터/정책)”가 강해짐.
    
- **트레이드오프** (발생하는 손해)
    중앙이 장애 나면 전체가 멈춤(단일 장애점), 사용자 수가 늘면 중앙 성능/확장이 병목.

### 2) 1969–1970s: ARPANET과 “네트워크越 자원 공유”

- **왜 중요했나**  
    ARPANET처럼 네트워크가 생기면서 “내 컴퓨터가 아닌 **원격 컴퓨터의 자원**”을 쓰는 패턴이 본격화됨(원격 로그인, 파일 전송 등). 
    → 이때부터 ‘요청하는 쪽/제공하는 쪽’ 역할 분리가 더 뚜렷해짐(용어는 시대에 따라 host/user-host 등으로도 표현).
    
- **트레이드오프**  
    네트워크 지연/끊김/프로토콜 호환성 같은 “현실 세계(선로/라우팅)” 문제가 소프트웨어 설계의 핵심 리스크가 됨.

### 3) 1980s: PC/워크스테이션 확산 → “처리는 분산, 데이터는 중앙”

- **왜 클라이언트–서버가 ‘현대적 의미로’ 뜸**  
    회사/조직에 PC·워크스테이션이 깔리면서, 화면/입력/일부 처리는 **개별 기기(클라이언트)** 가 맡고, 데이터·공유 자원·정책은 **서버**에 두는 구조가 급부상. 
     
 - 철학 3개가 “실전 패턴”이 됨:
    - **관심사 분리**: UI/입력(클라) ↔ 데이터/규칙(서버)
        
    - **중앙 통제**: 권한/로깅/정책을 서버로 모음
        
    - **다중 클라이언트 대응**: 같은 서버 기능을 여러 PC에서 씀
    
- **트레이드오프**  
    분산되면서 배포/버전/호환 문제가 급격히 커짐(각 PC에 설치된 클라이언트가 제각각이면 운영 지옥).

### 4) 1989–1991: WWW/HTTP 등장 → “브라우저(클라) + 웹서버(서버)”가 표준이 됨

- **왜 ‘서버에서 서비스 제공’이 폭발적으로 효율적이었나**  
    웹은 **브라우저(클라이언트)** 만 있으면 되고, 서비스 로직/콘텐츠는 **서버**에서 제공하면 되니 배포가 압도적으로 쉬웠음. HTTP도 이 시기(1989–1991)에 설계/발전. 
    팀 버너스리도 웹이 커지면서 “대규모 소비자에게 (당시엔) 무거운 서버들이 읽기 위주로 제공”하는 형태로 확장됐다고 회고함.
    
- **트레이드오프**  
    사용자가 폭증하면 서버가 병목 → 캐시/프록시/CDN/로드밸런싱 같은 “서버 측 확장 기술”이 필수가 됨.  
    그리고 네트워크(인터넷) 위에서 동작하니 **지연·실패·재시도**가 상수로 따라붙음.

### 5) 1990s–2000s: 엔터프라이즈 2-Tier → 3-Tier(서버 역할 분화)

- **왜 서버가 더 “중앙화”됐나**  
    DB 무결성, 권한, 감사 로그, 트랜잭션 같은 걸 각 클라이언트에 흩뿌리면 사고가 나기 쉬워서, **DB 서버 + 애플리케이션 서버(중간 계층)** 로 정책/로직을 모으는 3-Tier가 일반화. (관심사 분리 강화)
    
- **트레이드오프**  
    서버가 늘수록(웹서버/앱서버/DB/캐시) 네트워크 홉이 늘고 장애 지점이 늘어남. 운영(관측/배포/롤백)이 더 중요해짐.


### 6) 2010s–현재: 모바일 + 클라우드 + API → “다중 클라이언트”가 기본값

- **왜 지금도 클라–서버가 유효한가**  
    모바일/웹/파트너 API 등 클라이언트가 다양해질수록, 핵심 규칙과 데이터는 서버에서 제공하는 게 재사용/통제가 쉬움(다중 클라이언트 대응의 극대화).
    
- **트레이드오프(더 커진 형태)**  
    마이크로서비스/분산 시스템은 “네트워크 비용 + 상태/일관성 + 버전 호환” 문제가 더 자주/더 크게 터짐. 그래서 관측(로그/메트릭/트레이싱)과 계약(API 스키마/버전 전략)이 사실상 설계의 일부가 됨.

---

# 3) 내부에서 실제로 일어나는 일(자료구조/파일/메모리/네트워크) — 단계별

아래는 “브라우저가 `GET /api/posts` 호출” 같은 전형적인 API 요청 기준 흐름이야.

### (A) 클라이언트 내부

1. **요청 구성**
    - URL, HTTP 메서드(GET/POST…), 헤더(Authorization, Content-Type…), 바디(JSON 등)를 구성
    
2. **DNS 조회(도메인 → IP)**
    - OS/브라우저 캐시 → 없으면 DNS 서버 질의 → IP 획득
    
3. **TCP 연결**
    - 3-way handshake로 연결 수립(커널 소켓/파일 디스크립터 생성)
    
4. **TLS(HTTPS일 때)**
    - 인증서 검증 + 암호화 키 협상(핸드셰이크)
    
5. **HTTP 요청 전송**
    - 요청 바이트 스트림이 커널 송신 버퍼 → 네트워크로 나감
    
### (B) 네트워크 경로

6. **라우팅**
    - 라우터/ISP/클라우드 네트워크를 거쳐 서버(혹은 로드밸런서) 도착
    
7. **로드밸런서(있다면)**
    - 여러 서버 중 하나로 전달(라운드로빈/최소 연결 등)
    
### (C) 서버 내부

8. **수신 소켓에서 요청 읽기**
    - 커널 수신 버퍼 → 웹서버/프레임워크가 HTTP 파싱(요청라인/헤더/바디)
    
9. **라우팅 & 미들웨어**
    - `/api/posts`에 매핑된 핸들러로 전달
    - 인증/권한 검사, 로깅, 레이트리밋, 입력 검증 등이 여기서 실행
    
10. **비즈니스 로직 실행**
	- 예: “게시글 조회 권한 확인 → DB 쿼리 준비”
    
11. **DB 접근**
    - DB 커넥션 풀에서 커넥션 빌림
	- 인덱스 탐색(B-Tree 등) → 디스크/메모리(버퍼풀)에서 데이터 읽음 → 결과 반환
	  
12. **응답 생성**
	- 상태코드(200/401/500…), 헤더, 바디(JSON/HTML) 작성
    
13. **응답 전송**
	- 서버 프로세스 → 커널 송신 버퍼 → 네트워크 → 클라이언트로 전달
	
### (D) 클라이언트가 응답을 반영

14. **응답 파싱 & UI 반영**
	- JSON 파싱 → 화면 렌더링/상태 업데이트
	- 캐시(브라우저/앱) 업데이트 가능

---

# 4) 재현 절차  (명령어/예상 출력/체크 포인트)

로컬에서 “클라이언트–서버 요청–응답”을 제일 쉽게 재현하는 방법 2개.

### 실험 1) 로컬 서버 띄우고 curl로 호출하기 (가장 직관적)

**서버 실행(터미널 1):**

```bash
python3 -m http.server 8000
```
![[스크린샷 2026-01-05 오후 3.40.56.png]]
**클라이언트 요청(터미널 2):**

```bash
curl -i http://127.0.0.1:8000/
```
1) `curl`
	- **curl = 클라이언트 역할**을 하는 커맨드라인 도구야.
	- URL로 요청을 보내고, 서버가 준 응답을 터미널에 보여줘.
2) `-i` 옵션 의미
	- `-i` = **include headers**
	- 즉, 응답의 **본문(body)** 뿐 아니라, 위쪽에 붙는 **HTTP 응답 헤더(header)** 까지 같이 보여줘.
	-  `-v`는 요청/응답을 더 자세히(디버깅용) 보여주는 옵션이고, `-I`는 “헤더만” 받는 옵션

**예상 출력(대략):**

- `HTTP/1.0 200 OK`
- `Server: SimpleHTTP/...`
- `Content-type: text/html; charset=utf-8` (또는 디렉터리 리스트 html)
- HTML 본문 일부

**체크 포인트**
- `curl -i` 결과에서 **Status Line(200 OK)**, **Header**, **Body**가 구분돼 보이는지
- 서버 터미널에 요청 로그가 찍히는지 (`"GET / HTTP/1.1" 200 -
![[스크린샷 2026-01-05 오후 3.44.58.png]]
![[스크린샷 2026-01-05 오후 3.46.02.png]]

---

### 실험 2) 네트워크 레벨(소켓/연결)을 “눈으로” 보기

**열려 있는 리스닝 포트 확인(서버 실행 후):**

```bash
lsof -iTCP:8000 -sTCP:LISTEN
```
1) 컴퓨터에서 TCP 8000번 포트를 ‘열고 대기(Listen)’ 중인 프로세스가 누구인지 찾아봐
2) `lsof`
	- **L**ist **O**pen **F**iles
	- macOS/유닉스에서 “열려 있는 파일” 목록을 보여주는 도구.
	- 여기서 중요한 포인트: **소켓(socket)도 OS 입장에선 ‘파일처럼’ 다뤄져서** lsof로 조회가 가능해.  
    (즉, “포트를 열었다” = “네트워크 소켓 파일을 열었다”에 가깝다)
3) `-iTCP:8000`
	- `-i` : 네트워크 관련 “열려 있는 것”만 필터링
	- `TCP` : TCP 프로토콜만
	- `:8000` : 그 중에서도 **포트 번호가 8000인 것만**
	- 결과적으로: **TCP 8000 포트와 관련된 소켓**만 보여줘.
4) `-sTCP:LISTEN`
	- `-sTCP` : TCP 상태(state)로 필터링
	- `LISTEN` : 그 상태가 **LISTEN(연결 요청을 기다리는 중)** 인 것만
5) curl = “클라이언트가 되어 실제로 HTTP 요청을 보내는 도구”
    
6) lsof = “OS에서 어떤 프로세스가 어떤 포트/소켓을 열었는지 보는 관찰 도구”
   
**예상 출력(대략):**
- `python3 ... TCP *:8000 (LISTEN)`

**연결이 실제로 생기는지 확인(요청 보내고 나서):**

```bash
lsof -iTCP:8000
```
1) `lsof -iTCP:8000` 는 **“내 컴퓨터에서 TCP 8000번 포트를 쓰고 있는(관련된) 모든 프로세스/연결을 보여줘**

![[스크린샷 2026-01-05 오후 4.07.11.png]]

**체크 포인트**

- LISTEN은 “서버가 기다리는 상태”
- 요청을 보내면 ESTABLISHED 같은 연결 상태가 잠깐 보일 수 있음(환경에 따라 순간적)

---

# 5) 흔한 오해 3개 + 반례

### 오해 1) “클라이언트는 항상 브라우저고 서버는 항상 한 대의 컴퓨터다”

- **반례**: 모바일 앱(클라이언트) + API 서버(여러 대) + DB 서버(별도) + 캐시 서버(별도).  
    서버는 “한 대”가 아니라 **역할 묶음**일 수 있고, 뒤에 수평 확장(여러 대)이 흔함.
### 오해 2) “서버가 있으면 무조건 DB가 있다”

- **반례**: 계산만 해주는 환율 변환/단위 변환 같은 서비스는 **DB 없이도** 동작 가능.  
    또는 DB 대신 캐시/파일/외부 API에만 의존하기도 함.

### 오해 3) “클라이언트–서버는 항상 상태를 기억(세션)한다”

- **반례**: HTTP는 기본적으로 **무상태(stateless)** 성향이라, 서버는 요청마다 토큰(JWT 등)으로 인증을 확인하고  
    “서버 메모리에 세션을 꼭 들고 있지 않는” 구조가 매우 흔함(확장성 때문에)    

---
# 6) SPOF

> [!note] SPOF(잠재적 단일 장애 지점) 요약  
> **SPOF(Single Point of Failure)**는 한 구성요소가 고장나면 **전체 서비스가 멈추거나 핵심 기능이 마비되는 지점**을 뜻.  
> 예: 단일 DB 인스턴스, 단일 로드밸런서, 단일 인증 서버처럼 “대체 경로/이중화”가 없는 핵심 컴포넌트.  
> 실무에선 **이중화(HA), 장애 조치(Failover), 분산/복제, 헬스체크**로 SPOF를 제거/완화한다.