# 버전 관리 시스템(VCS)으로 Git을 이해하기 위한 “정확한 기초”

> [!info] Git (정의)  
> Git은 **무료 오픈 소스 분산 버전 관리 시스템(DVCS)**이다.  
> Git은 소규모부터 매우 대규모 프로젝트까지 **속도(speed)**와 **효율성(efficiency)**을 목표로 설계되었다.

---

## 0) 왜 VCS가 “필연”이었나: OS/파일 시스템의 한계

> [!info] 핵심 요약  
> 운영체제(OS)의 파일 시스템은 “현재 상태 저장”에는 강하지만,  
> **과거 상태(History)**, **변경 이유/주체(메타데이터)**, **협업 충돌 해결**을 시스템적으로 제공하지 않는다.  
> VCS는 파일 시스템 위에 “시간축 + 협업” 계층을 올린 것이다.

### 0-1) 파일 시스템이 기본적으로 제공하는 것

- 파일 내용(contents)
- 경로(path)
- 메타데이터(stat): 크기(size), 수정시간(mtime), 권한(mode), 소유자(owner) 등
- “현재 상태”의 저장/읽기
    

### 0-2) 파일 시스템이 기본적으로 제공하지 않는 것

- “이 파일이 **어제** 어떤 내용이었는가?” (과거 스냅샷)
- “왜 바뀌었는가? 누가 바꿨는가?” (커밋 메시지/작성자/시간)
- “두 사람이 동시에 바꿨을 때 무엇이 정답인가?” (병합/충돌)
- “여러 파일이 한 기능으로 묶여 바뀌었는데, 이걸 **하나의 단위**로 기록/복원하는가?” (원자성)

> [!info] Undo(Ctrl+Z)의 한계  
> 에디터의 Undo는 보통 **프로세스 메모리(RAM)**에 존재한다.  
> 저장/종료하면 Undo 기록은 날아가고, 디스크에는 “결과물”만 남는다.  
> VCS는 Undo를 “프로젝트 역사” 수준으로 영속화(persist)한다.

---

## 1) 정확한 용어와 모델

> [!info] 용어 요약
> 
> - **VCS**: 파일/프로젝트의 변경 이력을 저장·조회·병합하는 시스템
>     
> - **Repository**: 이력 데이터(버전, 메타데이터)를 저장하는 데이터베이스
>     
> - **Working Copy / Working Tree**: 사용자가 편집하는 실제 파일 집합
>     
> - **Revision / Changeset**: 한 번의 기록 단위(커밋). “변경 집합”
>     
> - **Delta**: 두 버전 사이 차이(편집 스크립트/패치로 표현)
>     
> - **Snapshot**: 특정 시점의 전체 상태(프로젝트 트리)
>     
> - **Merge(3-way merge)**: base(공통조상), ours, theirs를 사용해 결합
>     
> - **Conflict**: 자동 병합 불가. 사람이 의사결정 필요
>     
> - **Atomic Commit**: 변경 집합이 **전부 반영**되거나 **전혀 반영되지 않음**
>     
> - **Centralized VCS(CVCS)**: 중앙 서버가 “진실의 원천”
>     
> - **Distributed VCS(DVCS)**: 각 개발자가 전체 역사(또는 거의 전체)를 로컬에 가짐
>     

## 1) VCS (Version Control System)

> [!info] **정의**  
> 파일/프로젝트의 변경 이력을 **기록(record)**하고, 과거 상태를 **조회(view)**·**복원(restore)**하며, 여러 사람의 변경을 **병합(merge)**할 수 있게 하는 시스템.

### 1. 왜 필요한가(문제)

- 파일 시스템은 “현재 상태”만 잘 저장함 → “과거 상태”를 공식적으로 보관하지 않음
- 협업 시 같은 파일을 동시에 바꾸면 충돌 발생 → 누가 무엇을 바꿨는지 추적 필요
- 배포/릴리즈 같은 특정 시점으로 돌아가야 함

### 2. 내부적으로 무엇을 관리하나(핵심 데이터)

- **내용 데이터**: 파일 내용 자체 또는 그에 대한 참조(해시/델타)
- **메타데이터**: 누가(author), 언제(date), 왜(message), 무엇을(changes)
- **관계 데이터**: 버전들 사이의 부모-자식 관계(히스토리 그래프), 브랜치 관계

### 3. 동작 관점(기능 축)

- **기록(Commit)**: 특정 시점의 변경/상태를 “버전”으로 저장
    
- **비교(Diff)**: 버전과 버전, 혹은 작업중 파일과 버전의 차이를 계산
    
- **복원(Checkout/Update)**: 특정 버전의 파일 상태를 작업 공간에 재현
    
- **협업(Push/Pull/Sync)**: 여러 저장소 간 기록 교환
    
- **병합(Merge/Rebase)**: 서로 다른 변경 흐름을 결합
    

---

## 2) Repository (저장소)

> [!info] **정의**  
> 버전 관리 이력(버전 데이터 + 메타데이터 + 관계)을 저장하는 **VCS의 데이터베이스**.

### “데이터베이스”라는 말이 정확히 의미하는 것

- 단순히 파일 복사본이 아니라:
    
    - 버전 그래프(누가 누구의 부모인지)
    - 태그/브랜치 같은 참조(ref)
    - 저장 효율(중복 제거, 압축)
    - 무결성 검증(체크섬/해시)  
        를 포함하는 “**구조화된 저장소**”라는 뜻.
        

### 두 종류로 나눠 보면

- **로컬 저장소(Local repo)**: 내 PC에 있는 저장소
    
- **원격 저장소(Remote repo)**: 서버/호스팅(깃허브 등)에 있는 저장소

> [!info] 
> Git에서는 `.git/` 폴더가 “로컬 저장소” 그 자체.  
> SVN/CVS에서는 보통 서버가 저장소의 단일 원천.

---

## 3) Working Copy / Working Tree

> [!info] **정의**  
> 사용자가 직접 편집하는 “실제 파일들”의 집합. OS 파일 시스템 위에 존재하는 작업 공간.

### 중요한 포인트

- Working Tree는 **VCS의 기록**이 아니라, “현재 내가 만지고 있는 현실”이야.
    
- 그래서 여기엔:
    
    - 아직 커밋되지 않은 실험 코드
        
    - 임시 로그
        
    - 깨진 상태의 코드  
        가 존재할 수 있어.

### 동작 관점

- “특정 버전을 체크아웃”하면 저장소의 내용을 Working Tree에 **재현**
    
- 사용자가 편집하면 Working Tree가 바뀜
    
- 커밋(또는 스테이징)을 통해 그 변경이 저장소 이력으로 들어감

---
## 4) Revision / Changeset (확장판)

> [!info] 핵심 한 줄
> 
> - **Revision**은 “저장소가 특정 시점에 어떤 상태였는가?”를 가리키는 **식별자(이름표)**
>     
> - **Changeset**은 “그 상태로 가기 위해 무엇을 바꿨는가?”를 나타내는 **변경의 묶음(패치의 집합)**
>     
> 
> 둘은 같은 사건(커밋)을 **‘상태 관점’(revision)** vs **‘변경 관점’(changeset)**으로 본 두 표현이다.

---

### 4-1) Revision(리비전) — “상태를 식별하는 ID”

#### 정의

**Revision**은 저장소(repository)의 **하나의 ‘정확한 상태(state)’** 를 가리키는 식별자다.  
여기서 “상태”란 보통 “프로젝트 트리(파일/디렉터리들의 집합)”의 특정 시점 모습을 의미한다.

- “리비전 100” = “저장소가 그때(리비전 100 시점)에 가지던 전체 상태”
    
- “커밋 해시 abc123” = “저장소가 그 커밋 시점에 가지던 전체 상태”

#### 왜 ‘상태 식별자’가 필요한가?

- 배포 버전, 릴리즈, 장애 복구에서 “그 시점 상태”를 정확히 재현해야 함
    
- “어제 밤에 되던 상태로 롤백”처럼 시간을 기준으로 말하기보다  
    **명확한 참조점(ID)**로 말하는 게 오류를 줄임

#### Revision이 실제로 가리키는 것(시스템별)

- 어떤 시스템은 “프로젝트 전체 상태”
    
- 어떤 시스템은 “파일 하나의 상태”
    
- 어떤 시스템은 “상태 객체(스냅샷)를 가리키는 포인터”

→ 이 차이가 SVN/CVS/Git의 사용감 차이를 만든다.

---

### 4-2) Changeset(체인지셋) — “변경의 묶음”

#### 정의

**Changeset**은 “한 번의 기록(커밋/리비전 생성)으로 적용되는 변경의 집합”이다.  
즉, 여러 파일에 걸친 수정/추가/삭제를 **하나의 논리적 단위**로 묶은 것.

예:

- `login.js` 수정 + `auth.py` 수정 + `README` 수정  
    → “로그인 토큰 만료 처리”라는 changeset 1개

#### Changeset이 중요한 이유

- 기능은 보통 여러 파일을 동시에 바꿈(“한 몸”)
    
- 코드 리뷰/롤백/원인 추적(bisect)에 가장 자연스러운 단위가 “기능 단위 변경 묶음”임
    
- 원자적 커밋(Atomic Commit)은 결국 “changeset이 쪼개지지 않는다”는 보장

#### Changeset을 구성하는 변경 종류(일반적으로)

- 수정(modify)
- 추가(add)
- 삭제(delete)
- 이름변경(rename) / 이동(move) _(시스템에 따라 추적 방식 다름)_
- 권한/모드 변경(mode change) _(예: 실행 권한)_
    

> [!info] changeset = patch?  
> “changeset”은 개념적으로 “패치들의 묶음”에 가깝지만,  
> 시스템에 따라 실제 저장 형식은 패치(델타)일 수도 있고, 스냅샷일 수도 있다.  
> 즉 changeset은 “의미 단위”, delta는 “표현/저장 방식”에 더 가깝다.

---

## 4-3) Revision vs Changeset — 같은 사건을 보는 두 관점

### A) 상태 관점(State view): Revision

- “이 시점의 전체 파일 상태를 가져와”
- “리비전 120을 체크아웃해”
- “배포는 리비전 120 기준이었어”

### B) 변경 관점(Change view): Changeset

- “리비전 119에서 120으로 갈 때 바뀐 내용이 뭐야?”
- “이 changeset에서 어떤 파일이 바뀌었지?”
- “이 changeset을 되돌려(revert)”

#### 둘이 붙어 있는 이유(핵심)

대부분의 VCS에서 “기록 1번”은 동시에:

- 어떤 ‘새 상태’(revision)를 만들고
    
- 그 상태로 가는 ‘변경 묶음’(changeset)을 가진다.

---

## 4-4) SVN/CVS 스타일 (중앙집중형에서의 의미 차이)

### SVN: 전역 리비전(Global Revision) = “저장소 전체의 시점 번호”

> [!info] SVN 한 줄  
> SVN에서 revision 번호는 **저장소 전체**에 대해 1씩 증가한다.  
> 그래서 `r100`은 “프로젝트 전체가 r100 시점에 어떤 상태였는지”를 뜻한다.

### SVN에서 revision과 changeset

- **Revision (r100)**: 저장소 전체 스냅샷 “시점”
    
- **Changeset (r100 changes)**: r99 → r100에서 적용된 변경 묶음
    

SVN에서는 둘이 강하게 1:1로 묶여 있고, 번호로 관리되기 때문에

- “r200으로 돌아가자”가 매우 명확해.
    

### SVN이 이걸 왜 중요하게 만들었나?

CVS의 파일 단위 버전 때문에 “시점”을 말하기가 어려웠음.  
SVN은 아예 “프로젝트 전체에 하나의 시계”를 줘서 시점 추적을 해결.

---

## CVS: 파일 단위 리비전 = “프로젝트 시점”이 흐려짐

> [!info] CVS 한 줄  
> CVS는 파일마다 버전이 따로 올라가서 “프로젝트 전체가 어떤 시점이었나?”가 직관적이지 않다.

### CVS에서 revision과 changeset

- 파일마다 `main.c 1.12`, `util.c 1.7`처럼 따로 버전이 존재
    
- 커밋(논리적 changeset)은 존재하지만,  
    “저장소 전체의 전역 리비전 번호”가 없어서 시점 표현이 불편해짐
    

그래서 CVS에서는 역사적으로

- 날짜 기반 태그(tag by date)
    
- 릴리즈 태그  
    같은 것을 많이 사용했어.
    

---

# 4-5) Git 스타일 (DVCS/스냅샷 기반에서의 의미)

> [!info] Git 한 줄  
> Git에서 “revision”은 보통 숫자가 아니라 **커밋 ID(해시)**로 식별되는 “상태”이고,  
> 한 커밋은 “스냅샷(트리)”을 가리키므로 기본 모델이 **상태 중심**이다.

## Git의 “revision”은 무엇인가?

Git에서 revision은 보통 아래를 의미해:

- 커밋 객체(commit object)를 가리키는 ID(해시)
    
- 또는 그 커밋이 가리키는 트리(tree) 상태
    

즉:

- `commit A` = “그 시점의 프로젝트 스냅샷”을 가리키는 점(point)
    

### Git 커밋이 포함하는 정보(정확)

커밋 객체에는 대체로:

- `tree` 포인터(프로젝트 전체 스냅샷 루트)
    
- `parent` 포인터(부모 커밋 1개 이상)
    
- author/committer/날짜
    
- 메시지  
    가 들어간다.
    

→ 따라서 Git의 “revision = 커밋 해시”는 “상태 식별자”로 매우 정확함.

---

## Git에서 changeset은 뭐냐? (여기가 자주 헷갈리는 지점)

### 1) 개념적으로는 존재한다

사람이 보는 관점에서:

- 커밋 A는 “A의 부모 P에서 A로 올 때 바뀐 내용”을 가지고 있다.
    
- 우리는 그것을 “changeset”이라고 부를 수 있다.
    

즉, **changeset(A) = diff(P, A)** 라는 식의 관점이 가능해.

### 2) 하지만 Git은 “changeset만 저장”하지 않는다

여기가 결정적 차이야.

- 델타 중심 VCS는 “변경(패치)”를 주로 저장해서 버전을 구성한다면,
    
- Git은 “커밋이 가리키는 스냅샷(트리)”를 기본 단위로 삼는다.
    

그래서 Git은

- changeset을 “저장 데이터”로 반드시 가지고 있는 게 아니라,
    
- 필요할 때 `diff`로 계산하여 보여준다(개념적 changeset).
    

> [!info] Git에서 changeset은 “표현”  
> Git의 핵심 저장 모델은 스냅샷(트리)이고,  
> changeset은 보통 “부모 대비 차이(diff)”로 **계산되는 표현**이다.

### 3) 저장 방식(깊은 이해를 위한 핵심)

Git이 “스냅샷인데도 효율적인 이유”는:

- 파일 내용(blob)을 해시로 식별하고
    
- 동일한 내용은 같은 객체를 재사용(중복 제거)  
    하기 때문이야.
    

즉 Git 스냅샷은 “파일 전체를 매번 복사 저장”이 아니라

- 트리 구조가 “어떤 blob들을 가리키는지”만 바뀌는 형태라 효율이 나옴.
    

---

## Git에서 “revision” 용어가 더 넓게 쓰이는 이유

Git 문맥에서 “revision”은 종종

- 커밋 해시,
    
- 브랜치 이름(가리키는 커밋),
    
- 태그 이름(가리키는 커밋),
    
- `HEAD~1` 같은 상대 참조  
    까지 포함해서 “특정 커밋을 지칭하는 표현”으로도 쓰여.
    

즉:

- **revision = 특정 커밋을 가리키는 참조 표현 전체**  
    (commit-ish, rev-spec 같은 개념)
    

---

# 4-6) 한 문장 결론(암기용)

> [!info] 결론
> 
> - **Revision**: “그때 저장소가 어떤 상태였는가?”를 가리키는 **상태 ID**
>     
> - **Changeset**: “그 상태로 만들기 위해 무엇을 바꿨는가?”인 **변경 묶음**
>     
> - SVN은 revision이 “숫자(전역 시점)”, Git은 revision이 “해시(커밋)”
>     
> - Git은 저장 모델이 스냅샷이라 changeset은 주로 “diff로 계산되는 표현”이다.
>     

---

원하면 다음으로, 이 개념을 “스테이징(index)”에 바로 연결해서:

- Git에서 “다음 revision(다음 스냅샷)”을 만들기 위해  
    index가 어떻게 “예비 트리(virtual tree)” 역할을 하는지
    
- 왜 index가 있어야 changeset을 **핀셋처럼** 만들 수 있는지
    
- `git diff` / `git diff --staged`가 각각 “어떤 changeset 표현”을 보여주는지
    

까지 이어서 문서 스타일로 확장해줄게.
---

# 5) Delta

> [!info] **정의**  
> 두 상태(A와 B) 사이의 차이를 나타내는 데이터. 보통 **패치(patch)** 또는 **편집 스크립트(edit script)** 형태.

### 델타는 “파일 자체”가 아니라 “변경 지시서”

예:

- “12번째 줄 삭제”
    
- “45번째 줄에 이 문자열 삽입”
    
- “이 구간을 저 구간으로 치환”
    

### 델타의 두 가지 관점

1. **저장 관점**: 공간 절약(변경분만 저장)
    
2. **전송 관점**: 네트워크 동기화 효율(변경분만 전송)
    

### 한계

- 특정 과거 버전을 복원할 때 델타를 여러 번 적용해야 할 수 있음
    
- 바이너리나 구조적 데이터에서는 의미 있는 델타 만들기가 어렵거나 효율이 떨어짐
    

---

# 6) Snapshot

> [!info] **정의**  
> 특정 시점의 “프로젝트 전체 상태”를 하나의 단위로 본 것.  
> 즉, 파일들의 집합(트리 구조)의 상태를 말한다.

### 스냅샷 기반의 장점(개념적 단순성)

- “리비전 N은 프로젝트 전체가 이 상태였다”가 명확해짐
    
- 특정 시점 복원이 직관적
    

### Git에서의 스냅샷은 “복사본 덩어리”가 아님

- Git은 파일을 통째로 계속 복사해서 저장하는 게 아니라,  
    **내용 해시로 중복 제거**(같은 내용은 같은 객체 참조)하여 스냅샷을 효율적으로 관리해.
    

---

# 7) Merge (3-way merge)

> [!info] **정의**  
> 두 변경 흐름(브랜치)을 결합할 때, 공통 조상 **base**와 두 결과물 **ours/theirs**를 이용해 자동 결합을 시도하는 방식.

### 왜 “3-way”가 필요한가

단순히 ours와 theirs만 비교하면:

- 어떤 변경이 “새로 생긴 것”인지
    
- 어떤 변경이 “공통으로 있던 것”인지  
    구분이 어렵다.
    

그래서 base를 둬서:

- base → ours에서 무엇이 바뀌었는지
    
- base → theirs에서 무엇이 바뀌었는지  
    를 각각 계산한 뒤 결합한다.
    

### 동작 순서(개념)

1. base 찾기(공통 조상 커밋/리비전)
    
2. base→ours 델타 계산
    
3. base→theirs 델타 계산
    
4. 두 델타를 한 파일(또는 트리)에 적용
    
5. 겹치면 conflict
    

---

# 8) Conflict

> [!info] **정의**  
> 자동 병합 규칙만으로는 하나로 결정할 수 없는 충돌 상황. 사람이 선택/수정해야 한다.

### 언제 conflict가 나나(전형적 사례)

- 같은 파일의 같은 구간을 서로 다르게 수정
    
- 한쪽은 삭제, 한쪽은 수정
    
- 이동/이름 변경이 섞여 의미 해석이 어려움(시스템에 따라 다름)
    

### conflict의 본질

“컴퓨터가 정답을 판단할 근거가 없다.”  
그래서 VCS는 충돌 표시를 남기고 개발자에게 결정권을 넘긴다.

---

# 9) Atomic Commit (원자적 커밋)

> [!info] **정의**  
> 한 커밋(변경 집합)이 **전체가 성공**하거나, **전체가 실패**해야 한다는 성질.

### 왜 중요한가

기능 하나가 보통 여러 파일에 걸쳐 수정된다.

- 일부 파일만 반영된 상태는 “짝이 안 맞는 상태”가 되어 빌드/실행이 깨진다.
    
- 원자성이 없으면 저장소가 “일관성 없는 상태”로 오염될 수 있다.
    

### 구현 관점(개념)

- 트랜잭션처럼 처리한다:
    
    - 임시 영역에 변경 수집
        
    - 검증
        
    - 커밋 순간에 한 번에 반영
        
    - 실패면 롤백
        

SVN은 이걸 강하게 제공했고, Git도 커밋 자체는 로컬에서 원자적으로 생성돼(커밋 객체가 완결된 단위).

---

# 10) Centralized VCS (CVCS)

> [!info] **정의**  
> 중앙 서버 저장소가 “진실의 원천(single source of truth)”이며,  
> 클라이언트는 보통 작업 사본과 제한된 메타데이터만 가진 구조.

### 장점

- 중앙에서 권한/정책 관리가 쉬움
    
- 단일 서버 기준으로 통제/감사가 쉬움
    

### 단점(본질적인 구조적 제약)

- 서버 장애 = 전체가 마비
    
- 네트워크 의존(오프라인에서 제약)
    
- 로그/비교/브랜치 탐색 등도 서버 왕복이 생기기 쉬움
    
- 대규모에서 지연/속도 문제가 커질 수 있음
    

대표: CVS, SVN(전통적으로)

---

# 11) Distributed VCS (DVCS)

> [!info] **정의**  
> 각 개발자가 로컬에 “저장소(역사 포함)”를 가지고, 저장소끼리 변경 이력을 교환하는 구조.

### 핵심 차이: “작업 사본만”이 아니라 “저장소 자체”가 로컬에 있음

- 로컬에서 커밋/로그/비교/브랜치/머지가 빠름
    
- 오프라인에서도 대부분의 작업 가능
    
- 중앙 서버가 죽어도 로컬 저장소들이 역사 백업 역할을 할 수 있음(구조적으로 더 안전)
    

대표: Git, Mercurial 등

---

# 한 번에 연결해서 보는 그림(개념 연결)

> [!info] 관계 정리
> 
> - Working Tree에서 편집 → (변경 발생)
>     
> - 그 변경이 하나의 **Changeset/Revision(커밋)**으로 기록됨
>     
> - 기록은 Repository에 쌓임
>     
> - 기록 방식은 Delta 중심일 수도, Snapshot 중심일 수도 있음
>     
> - 협업 시 브랜치가 갈라지고, 다시 합칠 때 3-way Merge가 필요
>     
> - 자동 결합 불가하면 Conflict
>     
> - 커밋은 Atomic해야 저장소가 일관성을 유지
>     
> - 저장소가 중앙에 있으면 CVCS, 각자 갖고 있으면 DVCS
>     

---

## 2) Delta vs Snapshot: 저장/복원 동작원리까지

### 2-1) Delta 저장 방식(차이 저장)

- 저장할 때: V1과 V2를 비교해 “변경 스크립트(패치)”를 만든다.
    
- 복원할 때: Base + Patch들을 순서대로 적용(Apply)하여 목표 상태를 만든다.
    

**장점**

- 저장 공간을 크게 절약 가능(특히 텍스트 소스코드에서)
    

**단점**

- 특정 버전을 꺼낼 때 “조립 비용”이 발생  
    (히스토리가 길수록 비용 증가 가능)
    

### 2-2) Snapshot 저장 방식(상태 저장)

- 저장할 때: “그 시점의 전체 파일 상태”를 스냅샷으로 기록한다.
    
- 복원할 때: 스냅샷을 바로 꺼내면 된다.
    

**장점**

- 개념이 단순하고 특정 시점 복원이 빠름(조립이 적음)
    

**단점**

- 순수 스냅샷은 공간 비용이 커질 수 있음 → 그래서 보통 “중복 제거/압축/공유” 기법이 필요
    

> [!info] 현실의 시스템은 혼합한다  
> “자주 보는 최신은 빠르게”, “과거는 효율적으로”라는 목표 때문에  
> 많은 VCS는 **최신(full) + 과거(delta)** 같은 혼합 전략을 쓴다.  
> 대표가 RCS의 Reverse Delta.

---

# 3) 세대별 VCS의 설계 문제와 해결(작동원리 포함)

---

## A. SCCS (1972) — 초기 로컬 VCS, 텍스트 라인 기반 관리

> [!info] SCCS 핵심 요약  
> SCCS는 초기 유닉스 환경에서 소스코드 변경 이력을 관리하기 위한 로컬 VCS다.  
> 핵심은 **라인(line) 기반 역사 저장**이며, 요청한 버전을 만들 때 **필터링/재구성**이 필요하다.  
> 히스토리가 길어질수록 특정 버전 추출 비용이 커질 수 있고, 바이너리/대규모 확장에 취약했다.

### A-1) 설계 목표(당대의 문제)

- 파일 복사 백업의 혼돈 제거
    
- 누가/언제/무엇을 바꿨는지 기록
    
- 특정 시점으로 되돌리기 제공
    

### A-2) 저장 구조(개념적으로)

SCCS 계열은 다음을 한 저장 단위에 포함하려 한다.

- 파일의 여러 라인(살아있는 라인 + 삭제된 라인 + 추가된 라인)
    
- 각 라인의 유효 범위(어느 리비전에서 추가/삭제되었는지)
    
- 작성자/시간/로그 등 메타데이터
    

### A-3) 버전 추출(Checkout) 알고리즘 관점

요청 버전 vX를 만들 때:

1. 마스터 데이터(역사 포함)를 앞에서부터 순회
    
2. 각 라인에 달린 “리비전 조건”을 평가
    
3. vX에서 유효한 라인만 출력하여 working file 생성
    

**핵심**: “저장할 때 싸게, 꺼낼 때 계산”이 섞이는 구조가 될 수 있다.

### A-4) 한계(다음 세대로 가는 이유)

1. **성능/확장성**: 히스토리 길이 증가 → 추출/처리 비용 증가 가능
    
2. **텍스트 라인 전제**: 바이너리나 구조적 데이터에 부적합
    
3. **협업 모델 부족**: 네트워크 동시 협업이 기본 설계 목표가 아님
    

> [!info] 바이너리 문제를 정확히 말하면  
> “태그를 끼워넣어서 깨먹는다”는 비유는 직관적이지만,  
> 본질은 SCCS류가 **라인 기반 텍스트 diff/스크립트**를 전제로 하므로  
> 바이너리에서 의미 있는 델타 생성/병합이 어려운 구조적 한계가 크다.

---

## B. RCS (1982) — Reverse Delta + Lock 기반 로컬 협업(사실상 단일 편집)

> [!info] RCS 핵심 요약  
> RCS는 “최신 버전을 아주 빠르게” 꺼내기 위해 **Reverse Delta**를 도입했다.  
> 파일마다 `*,v` 컨테이너에 이력을 저장하며, 충돌을 피하기 위해 **Lock(잠금)** 모델을 사용했다.

### B-1) 왜 Reverse Delta가 필요했나?

실사용에서 개발자는 **대부분 최신(head)** 만 편집한다.

- SCCS류에서 최신 추출이 무겁다면 생산성이 크게 떨어짐
    
- 그래서 “최신은 통째로 저장하고 즉시 제공”하는 방향으로 설계
    

### B-2) 저장 구조: working file vs RCS file

- `main.c` : 작업 파일(사용자 편집 대상)
    
- `main.c,v` : RCS 기록 컨테이너(리비전, 로그, 델타, 잠금 정보)
    

### B-3) Reverse Delta 저장/복원 동작

- 저장 시점(ci):
    
    1. 새 파일을 최신(head) “전체(full text)”로 저장
        
    2. 기존 head는 “새 head에서 되돌리면 되는” 델타로 변환해 뒤로 밀림
        
- 복원 시점(co):
    
    - 최신(head)은 즉시 제공(조립 거의 없음)
        
    - 오래된 버전은 델타를 여러 번 적용해야 하므로 느려질 수 있음
        

### B-4) Lock(잠금) 모델의 의미

- 동시에 여러 사람이 같은 파일을 수정하면 병합 문제가 생김
    
- RCS는 이를 “병합으로 해결”하기보다 **사전에 차단(lock)**하는 전략
    

**장점**

- 충돌을 구조적으로 예방
    

**단점**

- 팀 규모가 커지면 대기/병목이 심해짐  
    (한 명이 잡고 있으면 다른 사람은 못 건드림)
    

---

## C. CVS (1986) — 네트워크 동시 협업, merge로 해결

> [!info] CVS 핵심 요약  
> CVS는 중앙 서버 기반(CVCS)으로, 여러 사람이 동시에 수정하도록 허용하고  
> 커밋 시점에 변경을 합치는(merge) 방식으로 Lock 병목을 줄였다.  
> 하지만 “파일 단위 버전 관리”와 “원자성 부족”이 큰 한계였다.

### C-1) 구조: 클라이언트/서버

- **서버**: 저장소(역사)의 단일 진실
    
- **클라이언트**: working copy를 받아 로컬에서 편집
    

### C-2) 동시성 모델: Copy-Modify-Merge

CVS의 협업 철학은 전형적인:

1. Copy(서버에서 복사 받음)
    
2. Modify(로컬에서 수정)
    
3. Merge(서버에 올릴 때 병합)
    

### C-3) 커밋/병합 처리(작동원리 관점)

- 사용자가 커밋 요청
    
- 서버는 “내가 기반으로 삼은 버전”과 “현재 서버 최신” 사이를 비교
    
- 겹치지 않으면 자동 병합
    
- 겹치면 충돌 선언 → 사용자가 해결 후 재커밋
    

### C-4) CVS의 치명적 결함: 원자성 부족(Atomicity)

여러 파일이 한 기능을 구성할 때, 커밋이 “파일별로 순차 반영”되면:

- 일부 파일만 새 버전, 일부는 옛 버전인 **불일치 상태(inconsistent state)**가 발생
    
- 이 상태는 다른 사용자가 체크아웃하면 “빌드 깨짐”으로 즉시 드러남
    
- 더 큰 문제: 저장소 자체가 오염될 수 있음
    

### C-5) rename/move의 한계(정확한 이유)

CVS는 설계상 “파일의 정체성(identity)”을 경로/이름에 강하게 묶었고,  
rename/move를 “역사로 기록되는 1급 연산”으로 다루지 못했다.

---

## D. SVN (2000) — 트랜잭션(원자적 커밋) + 프로젝트 단위 리비전

> [!info] SVN 핵심 요약  
> SVN은 CVS의 핵심 결함을 해결하기 위해 등장했다.
> 
> - 커밋을 **트랜잭션(Atomic Commit)**으로 처리
>     
> - 파일/디렉터리 이동/이름 변경을 더 잘 다룸
>     
> - 저장소 전체에 **전역 리비전**을 부여해 “시점”을 명확히 함  
>     하지만 여전히 중앙 서버 의존과 머지 비용 문제가 남았다.
>     

### D-1) 전역 리비전(Global Revision)의 정확한 의미

SVN에서 리비전 N은 “파일 하나의 버전”이 아니라,

- **저장소 전체가 리비전 N 시점에 어떤 트리였는가**를 뜻한다.
    

즉 리비전 번호는 “프로젝트 전체 상태의 시간축”이다.

### D-2) 원자적 커밋(Atomic Commit) = 트랜잭션

SVN은 커밋을 DB 트랜잭션처럼 다룬다.

**개념적 작동**

1. 변경분을 임시 트랜잭션 공간에 모음
    
2. 검증(무결성, 충돌 조건 등)
    
3. 성공이면 한 번에 반영 + 리비전 증가
    
4. 실패면 롤백(저장소에 흔적 없음)
    

### D-3) SVN이 남긴 문제(왜 DVCS/Git이 뜨나)

- 중앙 서버 의존(오프라인에서 제약)
    
- 네트워크 왕복 비용(로그/비교/브랜치 탐색)
    
- 브랜치/머지 운영 난이도(대규모에서 비용이 커짐)
    

---

# 4) 여기까지가 Git으로 가는 “정확한 문제 정의”다

> [!info] Git으로 이어지는 핵심 문제 4개
> 
> 1. **원자성**: “기능 단위로 여러 파일이 함께 변한다”
>     
> 2. **프로젝트 단위 시점**: “리비전/커밋은 프로젝트 전체 상태로 말해야 한다”
>     
> 3. **오프라인/속도**: “로그/비교/브랜치/머지를 로컬에서 빠르게”
>     
> 4. **병합 중심 개발**: “브랜치를 자주 만들고 자주 합친다(merge-heavy workflow)”
>     

---

원하면 이제 다음 장을 같은 스타일로 이어서:

# Git의 설계 철학과 내부 구조

- 왜 “DVCS”가 SVN의 한계를 직접 해결하는지
    
- Git의 **객체 모델(blob/tree/commit)**이 왜 “프로젝트 스냅샷”을 자연스럽게 만드는지
    
- 그리고 네가 궁금해하는 핵심:  
    **왜 Index(스테이징)가 ‘필연’이었는지**를  
    “커밋 준비 트리(virtual tree) + 성능 캐시 + merge 엔진” 관점에서  
    OS 수준 파일 읽기/해시 계산/트리 작성 과정까지 전부 포함해서 작성해줄게.
    

다음은 “Git 파트”를 어디부터 시작할까?

1. **중앙집중형 한계 → 분산의 의미(DVCS)부터**
    
2. **바로 Git 내부구조(blob/tree/commit/index)부터**