# GIT

> [!note] GIT
> Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.


위는 깃 공식 홈페이지에 가면 볼 수 있는 깃의 정의다.

Git은 소규모 프로젝트부터 매우 대규모 프로젝트 까지 빠르고 효율적으로 처리하도록 설계된, 무료 오픈 소스 **분산 버전 관리 시스템**입니다.

결론적으로 GIT이란 분산 버전 관리 시스템이라는 것을 알 수 있다. 그렇다면 분산은 무엇이고, 버전 관리 시스템은 무엇일까? 이를 알아야 깃에 대해 이해 할 수 있을 것 같다.

# 버전 관리 시스템

> [!info] 버전(version)
> 버전이란, 특정 시점의 상태나 개정 내역을 구분하기 위해 부여되는 고유한 식별자(번호·이름)이며, 동일한 대상의 서로 다른 상태를 구분하기 위해 사용되는 개념
> 즉, **변경·수정·개선이 이루어질 때마다 생성되는 ‘개별 상태의 기록 단위’**를 의미

GPT에 물어본 버전의 개념이다. 결국 버전 관리 시스템이란 이렇게 **같은 대상이 수정에 따라 다른 상태**가 되는 것을 관리하는 시스템을 뜻하는 것 같다. 

## 버전 관리 시스템의 역사(Gemini로 정리)

> [!info] (1960~70년대 초) 태초의 시대: 물리적 버전 관리 
> 하드웨어 상황 : 모니터도 없던 시절. 펀치 카드(종이)에 구멍을 뚫어 코딩.
> - 코드가 곧 종이 뭉치였습니다.    
> - 버전 관리 방법: 고무줄과 캐비닛
 >1. v1: 종이 뭉치를 고무줄로 묶어서 캐비닛 첫 번째 칸에 넣음.
 >2. v2: 종이 뭉치를 복사(새로 뚫음)해서 두 번째 칸에 넣음
 >3. **순서 섞이면 복구 불가.**

--- 

> [!info] (1972~) SCCS (1972) - 로컬 VCS(**Version Control System**)의 탄생
> **[하드웨어 상황]** 유닉스(Unix)와 터미널의 등장. 하드디스크 10MB가 수백만 원 하던 시절.
> 이때부터 **'파일(File)'**이라는 개념이 생겼고, 텍스트 에디터로 코딩하기 시작
> 여기서 **'Ctrl+Z'의 한계**가 명확해집니다.
> **당시 상황과 문제점**
> 1. **휘발성의 공포:** 램(RAM)의 휘발성 때문에 개발자들은 저장을 자주 해야 했습니다.
> 2. **무식한 백업:** `main.c.backup1`, `main.c.final`, `main.c.really_final`...
> 3. **족보 꼬임(Tangling):** 파일이 수십 개로 늘어나자, 개발자들은 "도대체 어떤 게 최신 파일이고, 3일 전 파일은 어디 갔지?"라는 혼란에 빠졌습니다.
>  
>  이러한 문제를 막고자 최조의 VSC인 
>  **SCCS** (Source Code Control System)가 탄생하게 된다
> 
> 작동 방식: "인터리브드 델타 (Interleaved Delta)
>- **[핵심 원리]** 원본 파일과 수정된 내용을 따로 저장하는 게 아니라, **하나의 파일 안에 섞어서(Weave)** 저장.
>- ### 3. SCCS의 한계점: "왜 RCS에게 밀려났나?"
>
>**치명적인 단점들**
>**① 속도가 너무 느리다 (최대 약점)**
>**② 바이너리 파일 관리 불가**

- **유닉스 (Unix): "거대한 중앙 두뇌"**
	- 1970~80년대에는 '개인용 컴퓨터(PC)'라는 개념 자체가 없었음
	- 그 시절 '컴퓨터'란 방 하나를 가득 채우는 냉장고만 한 기계(메인프레임/미니컴퓨터) 이 거대한 기계를 돌리는 운영체제가 바로 **유닉스**입니다.
	- 특징:  성능은 강력하지만, 엄청나게 비쌌습니다. 그래서 회사에 딱 한 대만 있었습니다
	- 역할:  모든 계산과 저장은 이 '중앙 두뇌'에서만 일어납니다.
	
- **터미널 (Terminal): "뇌 없는 모니터"**
	-  그냥 '키보드 달린 모니터' (CPU도 없고 하드디스크도 없습니다.)
	- 작동 방식 : 전선으로 전산실에 있는 유닉스 컴퓨터와 연결되어 있습니다
	    1. 내가 키보드로 `A`를 누른다.
	    2. 전선을 타고 전산실 유닉스로 신호가 간다.
	    3. 유닉스가 처리하고 화면에 `A`를 띄우라고 신호를 보낸다.
		4. 내 모니터에 초록색 글씨로 `A`가 뜬다.
    
- **왜 `Ctrl+Z` (Undo)는 휘발성인가?**
	- 이 환경에서 개발자가 vi 같은 에디터를 켜고 코딩을 합니다. 그런데 왜 에디터를 끄면 되돌리기가 안 될까요?
	- 이것은 **'램(RAM)'과 '하드디스크(Disk)**'의 역할 차이 때문
		- 상황: 코딩 중 (RAM의 세계)
			- 에디터를 켜고 타자를 치는 동안, 모든 데이터는 RAM(임시 작업대)에 있습니다.
			- 현재 코드 : RAM에 있음.
			- Undo 기록(되돌리기 목록) : "3분 전에 A 지웠음, 5분 전에 B 추가함..." 이라는 기록도 RAM 구석에 메모해 둡니다.
		- 사건: 저장하고 끄기 (Disk의 세계)
			- 개발자가 퇴근하려고 `:wq` (저장하고 종료)를 입력합니다.
			- 저장(Save): 컴퓨터는 RAM에 있는 '현재 코드(결과물)'만 하드디스크에 옮겨 적습니다.
			- 종료(Quit):** 프로그램이 종료되면, RAM에 있던 데이터는 전기가 끊기듯 싹 비워집니다.
			- 결과: RAM 구석에 적어놨던 **'Undo 기록'은 하드디스크에 저장되지 않았으므로 공중분해(휘발)** 됩니다.
		-  다음날 아침
			- 다시 파일을 열면, 하드디스크에는 **'결과물'만 남아있지 '과거의 기록'은 저장된 적이 없습니다.** 그래서 어제로 돌아갈 수 없는 것입니다.
	- 비유 :칠판(RAM)에 필기하고 지우고를 반복하다가, 수업 끝나고 중요 내용만 노트(Disk)에 베껴 적고 칠판을 지우고 나간 겁니다. 다음날 칠판을 보면 깨끗하죠? 지웠던 내용을 복구할 방법이 없는 것과 같습니다.

-  **"인터리브드 델타 (Interleaved Delta)"**
	- **핵심 원리** : 원본 파일과 수정된 내용을 따로 저장하는 게 아니라, **하나의 파일 안에 섞어서(Weave)** 저장합니다.
	  
	- **특징** : "모든 역사가 한 파일에 섞여 있다"
		- 보통 우리는 버전 1과 버전 2가 따로 있다고 생각하죠? 하지만 인터리브드 델타 방식은 **단 하나의 '마스터 파일(s-file)'** 안에 **삭제된 줄, 추가된 줄, 살아있는 줄**을 몽땅 다 집어넣습니다.
		- 대신, 줄마다 **꼬리표(Control Record)** 를 달아둡니다.
			- **비유:** 100년 된 법전이 있습니다. 법이 개정될 때마다 옛날 법조문을 지우고 새 종이를 끼우는 게 아니라, 옛날 법조문 위에 빨간 줄을 긋고 "1990년 폐지됨"이라고 쓰고, 바로 밑에 새 법조문을 쓰고 "1990년 신설됨"이라고 적어두는 식입니다.
			  
	- **실제 파일 구조**
		- 상황
		1. **Ver 1.0:** `A = 10`이라고 썼음.
		2. **Ver 2.0:** `A = 10`을 지우고, `A = 20`으로 고침.
		- **SCCS가 하드디스크에 저장한 실제 파일 모습 (`s.main.c`)**
	```
	 --- 파일 시작 ---
	@I 1.0     <-- (꼬리표: 버전 1.0에서 추가됨)
		A = 10
	@D 2.0     <-- (꼬리표: 버전 2.0에서 삭제됨)
	@E 1.0     <-- (꼬리표: 버전 1.0 끝)
	
	@I 2.0     <-- (꼬리표: 버전 2.0에서 추가됨)
		A = 20
	@E 2.0     <-- (꼬리표: 버전 2.0 끝)
	--- 파일 끝 ---
	```
	- 파일을 읽어내는 원리 (필터링)
		- 이제 사용자가 버전을 요청하면, SCCS 시스템은 이 마스터 파일을 **첫 줄부터 끝 줄까지 스캔**하면서 **필터링**을 수행합니다.
		  
		- Case 1: "야, 1.0 버전 꺼내와!" (Checkout v1.0)
			- 컴퓨터는 `1.0` 꼬리표만 따라갑니다. `2.0` 관련 꼬리표는 무시합니다.
				1. `@I 1.0` 만남 -> "오, 1.0 내용 시작이네. 포함하자."
				2. `A = 10` -> **출력**
				3. `@D 2.0` 만남 -> "이건 2.0 얘기잖아? 난 지금 1.0을 만들고 있으니까 무시해." (삭제 지시 무시)
				4. `@I 2.0` ... -> "이것도 2.0 거니까 무시."
				5. **결과물:** `A = 10`
				   
		- Case 2: "야, 2.0 버전 꺼내와!" (Checkout v2.0)
			- 컴퓨터는 `1.0` 내용을 기본으로 하되, `2.0` 꼬리표의 지시(삭제/추가)를 따릅니다.
				1. `@I 1.0` 만남 -> "일단 가져와."
				2. `A = 10` -> 가져오려고 했는데...
				3. `@D 2.0` 만남 -> "잠깐! 2.0에서는 이 윗줄을 삭제하라고 하네? **버려!**"
				4. `@I 2.0` 만남 -> "2.0에서 새로 추가된 거네? **포함해!**"
				5. `A = 20` -> **출력**
				6. **결과물:** `A = 20`

- **왜 인터브리드 델타 방식은 비효율적인가?**
  
	1. 속도가 너무 느리다: "최신 파일도 조립해야 함"
		1. 가장 많이 쓰는 건 **'최신 버전'** 인데, SCCS는 최신 버전을 꺼내는 게 가장 힘듭니다.
		2. **이유:** 파일 안에 10년 치 역사(삭제된 줄, 추가된 줄)가 전부 뒤섞여 있습니다.
		3. **과정:** 최신 파일(`v100`)을 열려고 해도, 컴퓨터는 **첫 줄부터 끝 줄까지 모든 태그를 검사**하며 "이건 옛날 거니까 빼고, 이건 최신 거니까 넣고..." 하는 **OX 퀴즈(필터링)**를 풀어야 합니다.
		4. **결과:** 역사가 길어질수록 파일을 여는 속도가 점점 느려집니다. (개발자에겐 고문이죠.)
    
	2. 바이너리 파일 관리 불가: 
	    1. 바이너리 파일(Binary File)은 쉽게 말해  "사람이 읽으라고 만든 게 아니라, 컴퓨터(기계)가 읽으라고 만든 파일" 입니다.
	    2. 컴퓨터 세상의 파일은 크게 딱 두 종류로 나뉩니다. '텍스트 파일과 '바이너리 파일'입니다. 이 둘의 차이를 알면 SCCS가 왜 이 파일을 다 깨먹었는지 단박에 이해하실 수 있습니다.
		3. 가장 쉬운 구별법: "메모장 테스트"
			- **텍스트 파일 (`.txt`, `.c`, `.py`, `.html`)**
				- **결과:** "Hello World", "안녕하세요" 처럼 글씨가 예쁘게 보입니다.
				- **특징:** 줄바꿈(Enter)이 '다음 줄로 가라'는 뜻으로 쓰입니다. 사람이 읽고 쓸 수 있습니다.
				- **구조:** 내용 중간에 글자 몇 개 끼워 넣어도 파일이 망가지지 않습니다. (그냥 내용이 추가된 것뿐이죠.)
					-  원본: `Hello`
					- SCCS: `@1.1 Hello @End`
					- 결과: 나중에 `@1.1`이랑 `@End`만 지우면 원래대로 돌아옵니다.
			- **바이너리 파일 (`.jpg`, `.mp3`, `.exe`, `.zip`)**
				- **결과:** `JFIFC...` 처럼 외계어(깨진 글자)가 나옵니다.
				- **특징:** 이건 글자가 아니라, 이미지의 색상 값, 소리의 파형, 압축된 데이터를 0과 1로 꽉 채워 넣은 것입니다.
			    - **구조:** "위치(순서)"가 생명입니다.
		        - 왜 SCCS가 바이너리 파일을 망가뜨렸나?
			        -  SCCS는 버전 관리를 한답시고 파일 중간에 `@1.1` 같은 꼬리표(텍스트)를 강제로 끼워 넣는다고 했죠?
			        - 텍스트 파일에 끼워 넣는 건 괜찮습니다.하지만 바이너리 파일(예: 이미지)에 이걸 끼워 넣으면 대참사가 일어납니다
			        - 이미지 파일의 구조로 예시
				        - 이미지 파일은 약속된 **위치**가 중요합니다.
				        - **0~10번째 칸:** "이건 JPG 파일입니다" (헤더)
				        - **11~20번째 칸:** "가로 500픽셀, 세로 500픽셀입니다" (정보)
				        - **21번째 칸부터:** "빨간색 점, 파란색 점..." (실제 그림 데이터)
				        - SCCS가 파일 맨 앞에 `@1.1`이라는 글자(4칸 차지)를 쑤셔 넣습니다.
				        - **0~3번째 칸:** `@1.1` (SCCS 태그가 들어감)
				        - **4~14번째 칸:** "이건 JPG..." (원래 0번째에 있어야 할 헤더가 뒤로 밀림)
				        - **결과:** 이미지 뷰어가 파일을 엽니다.
				        - "어? 0번째 칸에 'JPG'라는 신호가 있어야 하는데 이상한 글자(@1.1)가 있네? **이거 깨진 파일이잖아! 에러!**"
				- **결론:** 바이너리 파일은 데이터가 **1바이트라도 밀리면(Shift)** 전체 구조가 엉망이 되어버립니다. 그래서 중간에 태그를 끼워 넣는 SCCS 방식으로는 절대 관리할 수 없었던 것입니다.

---

> [!info]  RCS (1982)**Revision Control System**(수정 관리 시스템)
>1972년에 나온 SCCS 덕분에 개발자들은 "역사 저장"은 할 수 있게 되었습니다. 하지만 10년 써보니 **치명적인 불만**이 터져 나왔습니다.
>1. **불만  (속도)**: "아니, 나는 맨날 최신 파일만 작업하잖아? 근데 SCCS 이 녀석은 최신 파일 한번 열려면 태그 계산하느라 한참 걸리네?"
>2. **불만  (접근성)**: "SCCS는 유닉스 사면 끼워주는 거라 비싸고 폐쇄적이야. 누구나 쓸 수 있는 무료 툴 없나?"
>   
>이 불만을 해결하기 위해 **티치(Walter F. Tichy)**라는 사람이 1982년에 **RCS(Revision Control System)**를 내놓았습니다.
>
 > # RCS의 슬로건: "과거는 느려도 된다. 하지만 지금 당장 일해야 하는 '최신 버전'은 0.1초 만에 열려야 한다!"
> -  그래서 탄생한 게 **RCS(1세대 버전 관리)**입니다.
> - 기존 에디터:`code.c` (최종본)만 저장함.
> - **RCS의 방식: `code.c,v` 라는 특수한 파일을 만들어서 "최종본 + 그동안의 모든 변경 내역(델타)"을 하드디스크에 박제해버립니다.**
> 
>  # RCS의 핵심 기술: "역방향 델타 (Reverse Delta)"
>  - SCCS는 모든 줄을 뒤섞어서(Interleaved) 저장했기 때문에 느렸습니다. RCS는 이를 타파하기 위해 **저장 순서를 뒤집는 혁신**을 도입했습니다.

- **RCS 파일 관리 메커니즘""**
	- RCS는 파일 원본에 낙서(태그)를 하는 SCCS 방식을 버리고, **파일을 안전하게 감싸는 '컨테이너(포장 박스)' 방식**을 도입했습니다.
	
	1. 파일 구조: "작업실과 창고의 분리"
		- RCS를 사용하면 폴더에 두 종류의 파일이 공존합니다
		- **`main.c` (작업 파일):** 개발자가 눈으로 보고 수정하는 **현재의 파일**입니다.
		- **`main.c,v` (역사 파일):** 일명 **'콤마 브이'** 파일. 이 안에 **최신 파일 원본 + 과거 기록들 + 잠금 정보** 가 모두 들어있는 **창고(Database)** 입니다.
    
	 2. 내부 저장 원리: "역방향 델타 (Reverse Delta)"
		- `main.c,v` 창고 안을 들여다보면, 아주 영리한 순서로 데이터가 쌓여 있습니다.
		- 최상단 (Head): 최신 버전(v3)이 통째로 들어있습니다. (가장 자주 쓰니까!)
		- 그 뒤 (Deltas): 과거 버전(v2, v1)은 "최신 버전에서 무엇을 빼야 하는지"에 대한 차이점(쪽지)으로 저장됩니다.
    
	3. 작동 시나리오 (Workflow)
		1. Check-out (대출/수정 시작)
			- **명령어:** `co -l main.c` (`-l`은 lock의 약자)
			- **동작:**
			    1. RCS가 `main.c,v` 창고를 엽니다.
			    2. 맨 앞에 있는 최신 내용을 쏙 꺼내서 `main.c` 파일을 만들어줍니다. (조립 과정이 없어서 엄청 빠름)
			    3. 창고(`main.c,v`) 겉면에 "잠금(Lock): 지금 철수가 작업 중임"이라고 딱지를 붙입니다. 이제 영희는 수정 못 합니다.
		2. Check-in (반납/저장)
			- **명령어:** `ci main.c`
			- **동작:**
			    1. 수정이 끝난 `main.c`가 들어옵니다.
			    2. RCS는 이 새로운 파일을 창고의 새 주인(New Head)으로 등록합니다.
			    3. 기존에 있던 옛날 최신본은 "새 주인과 뭐가 다른지(쪽지)"만 남기고 뒤로 밀어버립니다. (역방향 델타 생성)
			    4. 잠금(Lock)을 해제합니다.
	
	 4. 바이너리 파일 문제의 해결 (핵심!)
		 - SCCS는 파일 내용물 사이에 태그를 끼워 넣어서 이미지 등을 깨먹었지만, RCS는 이 구조 덕분에 바이너리 파일도 관리가 가능해졌습니다.
		- 포장 효과 (Encapsulation):
		    - RCS는 메타데이터(누가, 언제, 잠금 정보 등)를 `photo.jpg` 파일 내용 안에 적지 않습니다.
		    - 대신 `photo.jpg,v`라는 박스 겉면에 적습니다.
			- 결과:
			    - 박스 안의 `photo.jpg` 내용물(바이너리 데이터)은 건드리지 않고 원본 그대로 보존됩니다.
			    - 따라서 이미지가 깨지거나 실행 파일이 먹통이 되는 일이 사라졌습니다.
			- 한계:
			    - 바이너리 파일은 '빼기 공식(델타)'을 만들기 어려워서, 저장할 때 용량 압축 효율은 좋지 않았습니다.

-  **델타(Delta)**
	- 델타(Delta)의 정의
		- 델타(Delta, $\Delta$)는 수학이나 물리학에서 **변화량**을 뜻하는 기호에서 따왔습니다. 컴퓨터 공학에서의 정의는 다음과 같습니다.
		- **"두 데이터 사이의 '차이점(Difference)'만을 기록한 데이터 조각"**
		- 즉, 델타 방식이란 완성된 파일을 저장하는 것이 아니라, **"A를 B로 만들기 위해 필요한 변경 지시사항"만을 저장하는 기술입니다.
		- 파일 자체(File)가 아니라, **패치(Patch)** 혹은 **스크립트(Script)에 가깝습니다.
	
	-  역사적 등장 배경 : 저장소가 금값이었던 시대
		- 델타 방식이 처음 등장한 1970년대 후반 ~ 1980년대 초반은 '디지털 공간의 빈곤기'였습니다.
		- 하드디스크의 가격: 당시 10MB(메가바이트) 하드디스크 하나의 가격은 약 **300~400만 원**에 달했습니다. 지금 돈으로 환산하면 수천만 원이 넘는 가치입니다.
		
	- 개발자들의 딜레마
	    1. 코드를 짜다가 실수를 하면 되돌려야 하니 **백업(버전)은 반드시 남겨야 한다.**
	    2. 하지만 파일을 통째로 복사해서 남기기에는 **하드디스크가 너무 비싸고 작다.**
	    3. "파일을 통째로 저장하지 않으면서, 과거의 내용을 기억할 방법은 없을까?"
	       
	- 이 모순적인 상황을 해결하기 위해 엔지니어들은 파일의 '내용'이 아닌 '변화'에 주목하기 시작했습니다. 이것이 델타 방식의 시작입니다.
	
	- 작동 원리 (저장과 복원)
		- 델타 방식의 핵심은 '기준점(Base)'과 '변경사항(Delta)'의 결합입니다. 
		 
	- 저장 원리: "지시사항 기록하기"
		- 컴퓨터는 두 파일의 내용을 비교하여, 한 줄 한 줄 '무엇이 달라졌는지'를 분석해 기록합니다.
			1. 기준 파일 (V1)
				 - 내용: `안녕하세요`
				 - 이건 온전한 파일로 저장합니다.
			 2. 수정 발생: 사용자가 `안녕`으로 내용을 고침.
			 3. 델타 생성 (V2 저장):
			 - 컴퓨터는 V2 파일을 통째로 저장하는 대신, **델타 파일**을 만듭니다.
				 - 델타의 내용: `"3번째 글자부터 5번째 글자('하세요')를 삭제하라."`
					 - 이 명령어 텍스트 몇 바이트만 하드디스크에 저장됩니다.
		
	 - 복원 원리: "실시간 조립하기"
		 - 사용자가 "V2 파일을 보여줘"라고 요청하면, 컴퓨터는 하드디스크에 V2가 없기 때문에 **즉석에서 조립**을 시작합니다.
			 1. 재료 준비: 기준 파일(V1 `안녕하세요`)을 꺼냅니다.
			 2. 지시 이행: V2 델타(`'하세요' 삭제`)를 읽습니다.
			 3. 연산(Computing): CPU가 V1에서 '하세요'를 지우는 연산을 수행합니다.
			 4. 결과 출력: 연산 결과인 `안녕`을 메모리에 띄워 사용자에게 보여줍니다.
		
	 - 이처럼 델타 방식은 **저장할 때는 '차이'만 기록**하고, **읽을 때는 기준 파일에 차이점을 '적용(Apply)'하여 결과를 만들어내는 방식**입니다.

- **왜 델타 방식이어야만 했는가? (필연성)**
	- 이 방식은 단순히 효율적인 것을 넘어, 그 시대에는 **유일한 생존 전략**이었습니다.
	  
	1. 극단적인 용량 압축 (99% 절약)
		1. 소스 코드는 보통 수천 줄이 넘지만, 개발자가 하루에 수정하는 양은 고작 몇 줄에서 몇십 줄입니다.
		- 델타 방식 : 10,000줄을 또 저장하는 대신, 바뀐 5줄에 대한 정보만 저장하면 용량을 **1/2000**로 줄일 수 있습니다. 당시의 비싼 하드디스크 환경에서는 이것만이 버전을 무제한으로 관리할 수 있는 유일한 길이었습니다.
	2. 텍스트 기반의 특성
		1. 초기 컴퓨터 환경은 대부분 텍스트(Text) 기반의 소스 코드를 다뤘습니다.
		2. 텍스트는 "몇 번째 줄을 지워라", "몇 번째 줄에 단어를 끼워 넣어라" 같은 편집 명령어(Edit Script)로 변환하기가 매우 쉬웠습니다. 이 특성 덕분에 델타 방식이 효과적으로 구현될 수 있었습니다.

- **역방향 델타(Reverse Delta)** 방식
	- "과거는 중요하지 않아, 지금 당장 쓰는 최신 파일이 제일 중요해!"라는 철학으로 만들어진 기술
	- **우리가 생각하는 일반적인 방식 (정방향 델타)**
		1. v1 (원본): "안녕" (100MB, 통째로 저장)
		2. v2 (변경): v1 + "하세요" (v1에 '하세요'를 더하기)
		3. v3 (최신): v2 + " 반가워" (v2에 '반가워'를 더하기)
		4. 개발자: 야, 최신 파일(v3) 로드 - 컴퓨터 과부화
			1. v1 꺼냄.
			2. v2 델타 찾아서 더함.
			3. v3 델타 찾아서 더함.
			4. 최신 파일 여는 게 제일 느림
	- **역방향 델타 방식 (RCS의 방식)** (우리가 맨날 보는 건 최신 파일이잖아? 근데 왜 최신 파일 여는 게 제일 느려야 해?)
		- 순서를 뒤집어버립니다. 최신 파일을 '원본'으로 치고, 과거를 '변형본'으로 만드는 것
			1. v3 (최신 파일) : "안녕하세요 반가워" (100MB, **통째로 저장!**)
				1. 최신이니까 언제든 바로 꺼내 쓸 수 있게 실체를 보관합니다.
			2. v2로 가는 길 (빼기 공식) :  v3에서 '반가워'라는 글자를 빼면(Undo) v2가 돼.
				1. v3 - '반가워' = v2`
			3. v1으로 가는 길 (빼기 공식) : v2에서 '하세요'라는 글자를 빼면(Undo) v1이 돼.
				1. v2 - '하세요' = v1`
		- 장점
			- 개발자가 "야, 최신 파일(v3) 가져와!"라고 하면?
			- 컴퓨터: **"여기 옛다."** (0.1초)
			- 계산할 필요가 없습니다. 그냥 하드디스크에 저장된 덩어리를 바로 주면 됩니다.
		- 단점
			- "야, 3년 전 파일(v1) 가져와!"라고 하면
			- 컴퓨터: "으악..." (v3 가져와서... v2 공식 대입해서 빼고... v1 공식 대입해서 또 빼고...)
			- 과거로 갈수록 느려집니다. 하지만 개발자는 옛날 파일을 거의 안 보니까 괜찮습니다.
	- **실제 작동 과정 (시뮬레이션)**
		1.  `main.c` 파일 생성 (v1)
			1. 내용: `printf("Hello");`
			2. 하드디스크: `v1 (본체)`: `printf("Hello");`
		2. 내용 수정해서 저장 (v2)
			1. 내용: `printf("Hello World");` (" World" 추가됨)
			2. RCS의 행동
				1. 새로운 파일(v2)을 본체(Master)로 만듭니다.
				2. 옛날 파일(v1)은 **"v2에서 ' World'를 지우면 됨"이라는 쪽지(Delta)로 바꿔서 저장합니다.**
				3. `v1` 본체는 삭제합니다.
			3. 하드디스크
					1. `v2 (본체)`: `printf("Hello World");`
					2. `v1 (쪽지)`: `v2 - " World"
		3. 또 수정해서 저장 (v3)
			1. 내용: `printf("Hi World");` ("Hello"를 "Hi"로 바꿈)
			2. RCS의 행동
				1. 가장 최신 파일(v3)을 **본체**로 등극시킵니다.
				2. 직전 파일(v2)은 **"v3의 'Hi'를 'Hello'로 바꾸면 됨"**이라는 **쪽지**로 만듭니다.
			3. 하드디스크
				1. `v3 (본체)`: `printf("Hi World");`
				2. `v2 (쪽지)`: `v3 - "Hi" + "Hello"`
				3. `v1 (쪽지)`: `v2 - " World"`
	
	- 요약: 왜 이렇게 복잡하게 했을까?
		- "개발자는 99%의 시간 동안 '최신 파일'만 본다"는 사실 때문
		- 속도: 가장 자주 쓰는 최신 버전을 여는 속도(Access Time)를 '0'으로 만들기 위해.
		- 공간: 그러면서도 옛날 버전들을 통째로 저장하면 용량이 터지니까, 옛날 건 '공식(Delta)'으로만 남겨두기 위해.

---
> [!info] **CVS (1986)**  
> >CVS (Concurrent Versions System)
>RCS가 너무 훌륭했기 때문에, 개발자들은 이걸 인터넷으로 연결해서 여럿이 쓰고 싶어졌습니다. 그래서 딕 그룬(Dick Grune)이라는 사람이 RCS 파일을 쉘 스크립트로 엮어서 네트워크 기능을 추가한 것이 CVS입니다
>
>**1. 등장 배경: "잠금(Lock)을 풀고 협업을 허용하라"**
>
>RCS는 파일 수정 중 다른 사람이 접근하지 못하도록 막는 잠금 방식을 사용했기 때문에, 팀 단위 프로젝트에서는 누군가의 작업이 끝날 때까지 하염없이 기다려야 하는 병목 현상이 발생했습니다. 인터넷 보급과 함께 여러 개발자가 동시에 하나의 프로젝트를 수정해야 하는 상황이 오자, 잠금 없이도 동시 작업이 가능한 시스템이 절실해졌습니다.
>
>**2. 작동 원리: "동시성(Concurrency)과 병합(Merge)"**
>
>내부적으로는 RCS의 파일 관리 방식(.v 파일)을 그대로 엔진으로 사용하지만, 그 위에 네트워크 기능을 씌운 서버-클라이언트 구조입니다. 핵심은 잠금(Lock)을 없앤 것입니다. 개발자들은 자유롭게 최신 파일을 받아가서 수정하고, 서버에 다시 올릴 때 시스템이 변경 사항을 자동으로 합쳐줍니다(Merge). 만약 두 사람이 같은 줄을 수정했다면 시스템은 충돌(Conflict)을 선언하고 사람에게 해결을 요청합니다.
>
>**3. 효용: "글로벌 협업의 시작"**
>
>물리적으로 떨어진 개발자들이 인터넷을 통해 하나의 프로젝트를 공동으로 관리할 수 있는 길을 열었습니다. 파일을 수정하기 위해 대기하는 시간이 사라져 개발 생산성이 비약적으로 높아졌으며, 이는 1990년대 리눅스를 비롯한 수많은 오픈소스 프로젝트가 전 세계적인 규모로 성장할 수 있는 기술적 기반이 되었습니다.
>
>**4. 한계: "불완전한 트랜잭션과 관리의 어려움"**
>
>파일 단위로만 역사를 관리했기 때문에 치명적인 약점이 있었습니다. 파일 10개를 수정해서 올리다가 중간에 인터넷이 끊기면, 5개는 새 버전이고 5개는 옛날 버전으로 남는 등 데이터 무결성이 깨지는 문제(원자성 부족)가 발생했습니다. 또한 파일의 이름 변경이나 이동을 제대로 인식하지 못해 역사가 끊기는 일이 빈번했고, 프로젝트가 커질수록 속도가 느려지는 구조적 한계가 있었습니다.

 - **서버 (Server)**
	- 중앙 도서관
    - 프로젝트의 원본(Master)과 모든 역사(.v 파일들)를 보관하는 컴퓨터입니다.
    - 이곳이 파괴되면 프로젝트는 사라집니다. (중앙 집중식의 위험성)
    - **역할:** "파일 빌려주기"와 "반납받기"만 담당합니다.
      
- **클라이언트 (Client)**
	- 학생의 책상
    - 개발자(사용자)의 개인 컴퓨터입니다.
    - 서버에서 파일의 복사본을 다운로드(Check-out)받아 작업합니다.
    - **역할:** 실제 코딩과 수정 작업은 여기서 일어납니다
      
-  **동시성 (Concurrency)**
  
	- RCS 시절의 **잠금(Lock)** 방식과 비교하면 이해가 빠릅니다.
		- **RCS (잠금 모델):** "화장실 키" 방식.
		    - 철수가 파일을 수정하려고 가져가면(Lock), 영희는 철수가 반납할 때까지 그 파일을 수정할 수 없습니다. (대기 시간 발생)
		- **CVS (동시성 모델):** "구글 독스" 방식 (엄밀히는 조금 다르지만).
		    - 철수가 파일을 수정하는 동안, 영희도 **똑같은 파일을 다운받아 동시에 수정**할 수 있습니다.
		    - 서버는 누가 가져가는지 신경 쓰지 않습니다. "그래, 너도 가져가고 쟤도 가져가서 맘대로 고쳐봐."
		    - 이  방식 덕분에 개발 속도가 비약적으로 빨라졌습니다. 하지만 "나중에 어떻게 합치지?"라는 문제가 생깁니다.

- **병합 (Merge)**
	- 자동으로 합치기"
	- 서버는 아주 단순한 규칙으로 두 사람의 코드를 합칩니다. 이를 '줄 단위 병합'이라고 합니다.
		**상황** :  서버에 100줄짜리 `main.c` 파일이 있습니다.
		1. **철수:** 10번째 줄을 수정해서 서버에 올렸습니다. (성공)
		2. **영희:** 90번째 줄을 수정해서 서버에 올리려고 합니다.
		**작동 원리**
		- 서버(CVS)는 영희가 파일을 올릴 때(Commit), 먼저 올라온 철수의 파일과 비교합니다.
		1. **비교:** "철수는 10번째 줄을 고쳤고, 영희는 90번째 줄을 고쳤네?"
		2. **판단:** "수정한 위치가 서로 다르군. 겹치지 않아."
		3. **병합(Merge):** 철수의 10번째 줄 수정본 + 영희의 90번째 줄 수정본을 하나의 파일로 합쳐서 저장합니다.
		4. **결과:** 아무 문제 없이 두 사람의 코드가 섞였습니다. 이것이 Auto-Merge(자동 병합)입니다.-

- **충돌 (Conflict)** 
	- "기계는 선택할 수 없다"
	- 문제는 두 사람이 "같은 줄"을 수정했을 때 발생합니다. 컴퓨터는 어느 코드가 맞는 건지 판단할 지능이 없습니다.
	- **상황**
		1. **철수:** 50번째 줄 `color = red`를 `color = blue`로 고쳐서 서버에 올림. (저장 완료 v2)
		2. **영희:** 50번째 줄 `color = red`를 `color = green`으로 고쳐서 뒤늦게 올리려고 함.
	- **작동원리** 서버는 영희의 요청을 거절하고, 영희에게 "야! 충돌 났어. 네가 직접 보고 고쳐!"라며 파일을 되돌려 보냅니다. 이때 파일 내부에 한 기호를 심어서 보냅니다.
		- 영희의 컴퓨터에 있는 파일은 이렇게 변해 있습니다:
		- <<<<<<< : "여기서부터 네가 쓴 거야."
		- ======= : "구분선이야."
		- >>>>>>>: "이건 이미 서버에 저장된 놈(철수)이 쓴 거야."
		- 영희가 코드를 정리하고 특수 기호를 지운 뒤 다시 올리면, 그제야 서버는 저장을 받아줍니다.
		- (참고:  Git 예시지만, CVS의 충돌 마커와 형태가 거의 동일합니다)

---

> [!info] **SVN (2000)**  
> 
> > Subversion
> > 
> > CVS의 사용성은 유지하되 그 구조적 결함을 해결하기 위해 "CVS를 고치자(CVS is broken, fix it)"라는 목표로 탄생했습니다. CVS와 명령어는 비슷하지만, 내부는 데이터베이스 개념을 도입하여 완전히 새롭게 설계된 2세대 버전 관리의 완성형입니다.
> 
> **1. 등장 배경: "CVS를 고쳐서 완성형을 만들어라"**
> 
> CVS가 혁신적이긴 했지만 태생적으로 RCS 위에 껍데기만 씌운 구조였기에 한계가 명확했습니다. 파일 이름을 바꾸면 역사가 끊기고, 전송 중에 끊기면 데이터가 망가지는 등 불안정한 요소가 많았습니다. 이에 개발자들은 CVS의 사용 방법은 그대로 유지하되, 내부 구조를 밑바닥부터 뜯어고쳐 데이터가 절대 깨지지 않는 안전한 시스템을 만들고자 했고, 2000년에 그 결과물인 SVN이 등장했습니다.
> 
> **2. 작동 원리: "전역 리비전(Global Revision)과 원자적 커밋"**
> 
> CVS가 파일 하나하나를 관리했다면, SVN은 프로젝트 전체를 하나의 스냅샷처럼 관리합니다. CVS에서는 main.c는 v1.5, util.c는 v1.2처럼 파일마다 버전 번호가 제각각이었지만, SVN에서는 누군가 수정사항을 올릴 때마다 프로젝트 전체의 번호가 리비전 10, 리비전 11 하는 식으로 다 같이 올라갑니다. 또한 원자성(Atomicity) 개념을 도입하여, 파일 10개를 올리다가 중간에 인터넷이 끊기면 5개만 저장되는 것이 아니라 아예 0개로 취소 처리하여 데이터베이스를 깨끗하게 유지합니다.
> 
> **3. 효용: "2세대 버전 관리의 표준이자 기업의 사랑"**
> 
> CVS의 치명적인 단점이었던 불안정성을 완벽하게 해결했기 때문에, 2000년대 중반부터 대부분의 기업과 오픈소스 프로젝트가 SVN을 표준으로 채택했습니다. 파일뿐만 아니라 디렉터리(폴더)의 이동이나 이름 변경까지도 역사로 기록할 수 있게 되었고, 무엇보다 데이터가 꼬이거나 사라지지 않는다는 신뢰성을 제공하여 버전 관리 시스템의 대중화를 이끌었습니다.
> 
> **4. 한계: "중앙 서버라는 족쇄와 느린 속도"**
> 
> 여전히 중앙 집중식(Centralized) 구조였기 때문에 서버가 고장 나거나 인터넷이 연결되지 않으면 작업 기록을 볼 수도, 저장할 수도 없는 마비 상태가 되었습니다. 또한 모든 명령(로그 확인, 차이점 비교 등)을 수행할 때마다 서버와 통신해야 했기 때문에, 프로젝트 규모가 커질수록 속도가 매우 느려졌습니다. 특히 나뭇가지처럼 작업을 나누는 브랜치(Branch)를 만드는 건 쉬웠지만, 다시 합치는 병합(Merge) 과정이 너무 복잡하고 충돌이 자주 발생하여 개발자들에게 큰 고통을 주었습니다.

- CVS 파일 이름이 바뀌면 역사가 사라진다?
	- CVS는 '이름 바꾸기'라는 기능 자체가 없기 때문입니다."

CVS는 파일을 관리할 때 파일의 **'이름'**을 주민등록번호처럼 씁니다. 즉, 이름이 곧 그 파일의 정체성입니다.

- **상황:** 3년 동안 관리한 `old.c` (버전 100)의 이름을 `new.c`로 바꾸고 싶습니다.
    
- **우리의 기대:** `old.c`의 100개 버전 기록이 그대로 `new.c`로 이어지길 바랍니다.
    
- **CVS의 현실:** CVS에는 'Rename' 명령어가 없습니다. 그래서 꼼수를 씁니다.
    
    1. `new.c`라는 **새 파일을 만듭니다.** (버전 1부터 시작)
        
    2. `old.c`를 **지웁니다.** (삭제된 파일 보관소인 'Attic'으로 이동)
        

**[결과]**

- `new.c`의 역사를 조회하면: **"오늘 새로 만든 파일입니다 (버전 1)"**라고 나옵니다.
    
- `old.c`의 3년 치 역사는 '삭제된 파일' 속에 갇혀버립니다.
    
- **결론:** 두 파일 사이의 연결 고리가 없어서 역사가 뚝 끊기게 됩니다.
    

> **비유:** 개명을 했는데, 동사무소에서 "이름만 바꾸는 건 안 되고요, **기존의 당신을 사망 처리하고 새로운 아기로 다시 출생 신고하세요.**"라고 하는 것과 같습니다. 과거의 경력이 다 사라지는 거죠.