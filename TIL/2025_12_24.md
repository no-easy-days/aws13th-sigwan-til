
> [!m-callout] GIT
>Git은 **분산 버전 관리 소프트웨어 시스템**으로, 소스 코드나 데이터의 버전을 관리할 수 있다. 주로 여러 프로그래머가 협업하여 소프트웨어를 개발할 때 소스 코드를 관리하는 데 사용된다.
>
>- **원 개발자**: 리누스 토르발스    
>- **개발자**: 주니오 하마노 외
>- **최초 공개**: 2005년 4월 7일 (20년 전)
>- **안정 버전**: 2.52.0 (2025년 11월 17일)
>- **저장소**: git.kernel.org/pub/scm/git/git.git
>- **작성 언어**: 주로 C, GUI 및 스크립트는 셸 스크립트, Perl, Tcl, Python
>- **운영체제**: POSIX (Linux, macOS, Solaris, AIX), Windows
>- **사용 언어**: 영어
>- **유형**: 버전 관리 시스템
>- **라이선스**: GPL-2.0-only
>- **웹사이트**: git-scm.com# GIT

> [!info] GIT
> Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.


위는 깃 공식 홈페이지에 가면 볼 수 있는 깃의 정의다.

Git은 소규모 프로젝트부터 매우 대규모 프로젝트 까지 빠르고 효율적으로 처리하도록 설계된, 무료 오픈 소스 **분산 버전 관리 시스템**입니다.

결론적으로 GIT이란 분산 버전 관리 시스템이라는 것을 알 수 있다. 그렇다면 분산은 무엇이고, 버전 관리 시스템은 무엇일까? 이를 알아야 깃에 대해 이해 할 수 있을 것 같다.

# 버전 관리 시스템

> [!info] 버전(version)
> 버전이란, 특정 시점의 상태나 개정 내역을 구분하기 위해 부여되는 고유한 식별자(번호·이름)이며, 동일한 대상의 서로 다른 상태를 구분하기 위해 사용되는 개념
> 즉, **변경·수정·개선이 이루어질 때마다 생성되는 ‘개별 상태의 기록 단위’**를 의미

GPT에 물어본 버전의 개념이다. 결국 버전 관리 시스템이란 이렇게 **같은 대상이 수정에 따라 다른 상태**가 되는 것을 관리하는 시스템을 뜻하는 것 같다. 

## 버전 관리 시스템의 역사(Gemini로 정리)

> [!info] (1960~70년대 초) 태초의 시대: 물리적 버전 관리 
> 하드웨어 상황 : 모니터도 없던 시절. 펀치 카드(종이)에 구멍을 뚫어 코딩.
> - 코드가 곧 종이 뭉치였습니다.    
> - 버전 관리 방법: 고무줄과 캐비닛
 >1. v1: 종이 뭉치를 고무줄로 묶어서 캐비닛 첫 번째 칸에 넣음.
 >2. v2: 종이 뭉치를 복사(새로 뚫음)해서 두 번째 칸에 넣음
 >3. **순서 섞이면 복구 불가.**

--- 

> [!info] (1972~) 1세대: "Ctrl+Z는 휘발성이다" - 로컬 VCS의 탄생
> **[하드웨어 상황]** 유닉스(Unix)와 터미널의 등장. 하드디스크 10MB가 수백만 원 하던 시절.
> 이때부터 **'파일(File)'**이라는 개념이 생겼고, 텍스트 에디터로 코딩하기 시작
> 
> 여기서 **'Ctrl+Z'의 한계**가 명확해집니다.
> 
> **문제 발생:**
> 1. 에디터(`vi`)를 끄면 `Undo(되돌리기)` 기록이 다 날아감. (휘발성)
> 2. 오늘 수정한 게 마음에 안 들어서 "어제 파일"을 보고 싶은데, 이미 덮어쓰기 해버림.
> 3. 
- **유닉스 (Unix): "거대한 중앙 두뇌"**
	- 1970~80년대에는 '개인용 컴퓨터(PC)'라는 개념 자체가 없었음
	- 그 시절 '컴퓨터'란 방 하나를 가득 채우는 냉장고만 한 기계(메인프레임/미니컴퓨터) 이 거대한 기계를 돌리는 운영체제가 바로 **유닉스**입니다.
	- 특징:  성능은 강력하지만, 엄청나게 비쌌습니다. 그래서 회사에 딱 한 대만 있었습니다
	- 역할:  모든 계산과 저장은 이 '중앙 두뇌'에서만 일어납니다.
	
- **터미널 (Terminal): "뇌 없는 모니터"**
	-  그냥 '키보드 달린 모니터' (CPU도 없고 하드디스크도 없습니다.)
	- 작동 방식 : 전선으로 전산실에 있는 유닉스 컴퓨터와 연결되어 있습니다
	    1. 내가 키보드로 `A`를 누른다.
	    2. 전선을 타고 전산실 유닉스로 신호가 간다.
	    3. 유닉스가 처리하고 화면에 `A`를 띄우라고 신호를 보낸다.
		4. 내 모니터에 초록색 글씨로 `A`가 뜬다.
    
- **왜 `Ctrl+Z` (Undo)는 휘발성인가?**
	- 이 환경에서 개발자가 vi 같은 에디터를 켜고 코딩을 합니다. 그런데 왜 에디터를 끄면 되돌리기가 안 될까요?
	- 이것은 **'램(RAM)'과 '하드디스크(Disk)**'의 역할 차이 때문
		- 상황: 코딩 중 (RAM의 세계)
			- 에디터를 켜고 타자를 치는 동안, 모든 데이터는 RAM(임시 작업대)에 있습니다.
			- 현재 코드 : RAM에 있음.
			- Undo 기록(되돌리기 목록) : "3분 전에 A 지웠음, 5분 전에 B 추가함..." 이라는 기록도 RAM 구석에 메모해 둡니다.
		- 사건: 저장하고 끄기 (Disk의 세계)
			- 개발자가 퇴근하려고 `:wq` (저장하고 종료)를 입력합니다.
			- 저장(Save): 컴퓨터는 RAM에 있는 '현재 코드(결과물)'만 하드디스크에 옮겨 적습니다.
			- 종료(Quit):** 프로그램이 종료되면, RAM에 있던 데이터는 전기가 끊기듯 싹 비워집니다.
			- 결과: RAM 구석에 적어놨던 **'Undo 기록'은 하드디스크에 저장되지 않았으므로 공중분해(휘발)** 됩니다.
		-  다음날 아침
			- 다시 파일을 열면, 하드디스크에는 **'결과물'만 남아있지 '과거의 기록'은 저장된 적이 없습니다.** 그래서 어제로 돌아갈 수 없는 것입니다.
	- 비유 :칠판(RAM)에 필기하고 지우고를 반복하다가, 수업 끝나고 중요 내용만 노트(Disk)에 베껴 적고 칠판을 지우고 나간 겁니다. 다음날 칠판을 보면 깨끗하죠? 지웠던 내용을 복구할 방법이 없는 것과 같습니다.

---

> [!info]  **SCCS (1972)** -> **RCS (1982)**
>이 '휘발성' 때문에 개발자들은 미칠 지경.
>아니, 저장할 때 결과물만 저장하지 말고, 내가 지웠던 역사(Undo)도 하드디스크에 좀 남겨줘!
> **해결책:** "내 컴퓨터(로컬) 안에서라도 버전을 저장하자."
> -  그래서 탄생한 게 **RCS(1세대 버전 관리)**입니다.
> - 기존 에디터:`code.c` (최종본)만 저장함.
> - **RCS의 방식: `code.c,v` 라는 특수한 파일을 만들어서 "최종본 + 그동안의 모든 변경 내역(델타)"을 하드디스크에 박제해버립니다.**
> 
> 용량이 너무 비쌌기 때문에 **역방향 델타(최신 파일 + 빼기 공식)** 방식을 써서 용량을 쥐어짰습니다.
> 이때의 **협업**은 "이메일로 파일 보내기" 혹은 "플로피 디스크 던져주기"였습니다.

-  **델타(Delta)**
	- 델타(Delta)의 정의
		- 델타(Delta, $\Delta$)는 수학이나 물리학에서 **변화량**을 뜻하는 기호에서 따왔습니다. 컴퓨터 공학에서의 정의는 다음과 같습니다.
		- **"두 데이터 사이의 '차이점(Difference)'만을 기록한 데이터 조각"**
		- 즉, 델타 방식이란 완성된 파일을 저장하는 것이 아니라, **"A를 B로 만들기 위해 필요한 변경 지시사항"만을 저장하는 기술입니다.
		- 파일 자체(File)가 아니라, **패치(Patch)** 혹은 **스크립트(Script)에 가깝습니다.
	
	-  역사적 등장 배경 : 저장소가 금값이었던 시대
		- 델타 방식이 처음 등장한 1970년대 후반 ~ 1980년대 초반은 '디지털 공간의 빈곤기'였습니다.
		- 하드디스크의 가격: 당시 10MB(메가바이트) 하드디스크 하나의 가격은 약 **300~400만 원**에 달했습니다. 지금 돈으로 환산하면 수천만 원이 넘는 가치입니다.
		
	- 개발자들의 딜레마
	    1. 코드를 짜다가 실수를 하면 되돌려야 하니 **백업(버전)은 반드시 남겨야 한다.**
	    2. 하지만 파일을 통째로 복사해서 남기기에는 **하드디스크가 너무 비싸고 작다.**
	    3. "파일을 통째로 저장하지 않으면서, 과거의 내용을 기억할 방법은 없을까?"
	       
	- 이 모순적인 상황을 해결하기 위해 엔지니어들은 파일의 '내용'이 아닌 '변화'에 주목하기 시작했습니다. 이것이 델타 방식의 시작입니다.
	
	- 작동 원리 (저장과 복원)
		- 델타 방식의 핵심은 '기준점(Base)'과 '변경사항(Delta)'의 결합입니다. 
		 
	- 저장 원리: "지시사항 기록하기"
		- 컴퓨터는 두 파일의 내용을 비교하여, 한 줄 한 줄 '무엇이 달라졌는지'를 분석해 기록합니다.
			1. 기준 파일 (V1)
				 - 내용: `안녕하세요`
				 - 이건 온전한 파일로 저장합니다.
			 2. 수정 발생: 사용자가 `안녕`으로 내용을 고침.
			 3. 델타 생성 (V2 저장):
			 - 컴퓨터는 V2 파일을 통째로 저장하는 대신, **델타 파일**을 만듭니다.
				 - 델타의 내용: `"3번째 글자부터 5번째 글자('하세요')를 삭제하라."`
					 - 이 명령어 텍스트 몇 바이트만 하드디스크에 저장됩니다.
		
	 - 복원 원리: "실시간 조립하기"
		 - 사용자가 "V2 파일을 보여줘"라고 요청하면, 컴퓨터는 하드디스크에 V2가 없기 때문에 **즉석에서 조립**을 시작합니다.
			 1. 재료 준비: 기준 파일(V1 `안녕하세요`)을 꺼냅니다.
			 2. 지시 이행: V2 델타(`'하세요' 삭제`)를 읽습니다.
			 3. 연산(Computing): CPU가 V1에서 '하세요'를 지우는 연산을 수행합니다.
			 4. 결과 출력: 연산 결과인 `안녕`을 메모리에 띄워 사용자에게 보여줍니다.
		
	 - 이처럼 델타 방식은 **저장할 때는 '차이'만 기록**하고, **읽을 때는 기준 파일에 차이점을 '적용(Apply)'하여 결과를 만들어내는 방식**입니다.

- **왜 델타 방식이어야만 했는가? (필연성)**
	- 이 방식은 단순히 효율적인 것을 넘어, 그 시대에는 **유일한 생존 전략**이었습니다.
	  
	1. 극단적인 용량 압축 (99% 절약)
		1. 소스 코드는 보통 수천 줄이 넘지만, 개발자가 하루에 수정하는 양은 고작 몇 줄에서 몇십 줄입니다.
		- 델타 방식 : 10,000줄을 또 저장하는 대신, 바뀐 5줄에 대한 정보만 저장하면 용량을 **1/2000**로 줄일 수 있습니다. 당시의 비싼 하드디스크 환경에서는 이것만이 버전을 무제한으로 관리할 수 있는 유일한 길이었습니다.
	2. 텍스트 기반의 특성
		1. 초기 컴퓨터 환경은 대부분 텍스트(Text) 기반의 소스 코드를 다뤘습니다.
		2. 텍스트는 "몇 번째 줄을 지워라", "몇 번째 줄에 단어를 끼워 넣어라" 같은 편집 명령어(Edit Script)로 변환하기가 매우 쉬웠습니다. 이 특성 덕분에 델타 방식이 효과적으로 구현될 수 있었습니다.

- **역방향 델타(Reverse Delta)** 방식
	- "과거는 중요하지 않아, 지금 당장 쓰는 최신 파일이 제일 중요해!"라는 철학으로 만들어진 기술
	- **우리가 생각하는 일반적인 방식 (정방향 델타)**
		1. v1 (원본): "안녕" (100MB, 통째로 저장)
		2. v2 (변경): v1 + "하세요" (v1에 '하세요'를 더하기)
		3. v3 (최신): v2 + " 반가워" (v2에 '반가워'를 더하기)
		4. 개발자: 야, 최신 파일(v3) 로드 - 컴퓨터 과부화
			1. v1 꺼냄.
			2. v2 델타 찾아서 더함.
			3. v3 델타 찾아서 더함.
			4. 최신 파일 여는 게 제일 느림
	- **역방향 델타 방식 (RCS의 방식)** (우리가 맨날 보는 건 최신 파일이잖아? 근데 왜 최신 파일 여는 게 제일 느려야 해?)
		- 순서를 뒤집어버립니다. 최신 파일을 '원본'으로 치고, 과거를 '변형본'으로 만드는 것
			1. v3 (최신 파일) : "안녕하세요 반가워" (100MB, **통째로 저장!**)
				1. 최신이니까 언제든 바로 꺼내 쓸 수 있게 실체를 보관합니다.
			2. v2로 가는 길 (빼기 공식) :  v3에서 '반가워'라는 글자를 빼면(Undo) v2가 돼.
				1. v3 - '반가워' = v2`
			3. v1으로 가는 길 (빼기 공식) : v2에서 '하세요'라는 글자를 빼면(Undo) v1이 돼.
				1. v2 - '하세요' = v1`
		- 장점
			- 개발자가 "야, 최신 파일(v3) 가져와!"라고 하면?
			- 컴퓨터: **"여기 옛다."** (0.1초)
			- 계산할 필요가 없습니다. 그냥 하드디스크에 저장된 덩어리를 바로 주면 됩니다.
		- 단점
			- "야, 3년 전 파일(v1) 가져와!"라고 하면
			- 컴퓨터: "으악..." (v3 가져와서... v2 공식 대입해서 빼고... v1 공식 대입해서 또 빼고...)
			- 과거로 갈수록 느려집니다. 하지만 개발자는 옛날 파일을 거의 안 보니까 괜찮습니다.
	- **실제 작동 과정 (시뮬레이션)**
		1.  `main.c` 파일 생성 (v1)
			1. 내용: `printf("Hello");`
			2. 하드디스크: `v1 (본체)`: `printf("Hello");`
		2. 내용 수정해서 저장 (v2)
			1. 내용: `printf("Hello World");` (" World" 추가됨)
			2. RCS의 행동
				1. 새로운 파일(v2)을 본체(Master)로 만듭니다.
				2. 옛날 파일(v1)은 **"v2에서 ' World'를 지우면 됨"이라는 쪽지(Delta)로 바꿔서 저장합니다.**
				3. `v1` 본체는 삭제합니다.
			3. 하드디스크
					1. `v2 (본체)`: `printf("Hello World");`
					2. `v1 (쪽지)`: `v2 - " World"
		3. 또 수정해서 저장 (v3)
			1. 내용: `printf("Hi World");` ("Hello"를 "Hi"로 바꿈)
			2. RCS의 행동
				1. 가장 최신 파일(v3)을 **본체**로 등극시킵니다.
				2. 직전 파일(v2)은 **"v3의 'Hi'를 'Hello'로 바꾸면 됨"**이라는 **쪽지**로 만듭니다.
			3. 하드디스크
				1. `v3 (본체)`: `printf("Hi World");`
				2. `v2 (쪽지)`: `v3 - "Hi" + "Hello"`
				3. `v1 (쪽지)`: `v2 - " World"`
	
	- 요약: 왜 이렇게 복잡하게 했을까?
		- "개발자는 99%의 시간 동안 '최신 파일'만 본다"는 사실 때문
		- 속도: 가장 자주 쓰는 최신 버전을 여는 속도(Access Time)를 '0'으로 만들기 위해.
		- 공간: 그러면서도 옛날 버전들을 통째로 저장하면 용량이 터지니까, 옛날 건 '공식(Delta)'으로만 남겨두기 위해.

---

